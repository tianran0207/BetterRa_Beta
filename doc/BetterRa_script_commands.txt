//===== BetterRa 文檔 =======================================
//= BetterRa 腳本指令說明文件
//===== 作者: ================================================
//= BetterRa 開發團隊
//===== 最后更新: ============================================
//= 20161005
//===== 文檔簡介: ============================================
//= BetterRa 是基于 rAthena 進行二次開發的, 在 rAthena 官方支
//= 持的腳本指令基礎上, BetterRa 也拓展了一些腳本指令, 請參閱
//= 下面的說明, 它會重點介紹腳本指令的參數和用法.
//============================================================

腳本指令別名表
--------------

為了兼容一些其他服務端的腳本, 部分腳本指令擁有別名, 使用別名和使用原名的語法和效果是一樣的.

┌──────────────────────────────┬─────────────────────────────┐
│ 指令原名 (推荐使用)          │ 指令的別名                  │
├──────────────────────────────┼─────────────────────────────┤
│ *itemexists                  │ *existitem                  │
├──────────────────────────────┼─────────────────────────────┤
│ *setrenttime                 │ *resume                     │
├──────────────────────────────┼─────────────────────────────┤
│ *getequipexpiretick          │ *isrental                   │
├──────────────────────────────┼─────────────────────────────┤
│ *gethotkey                   │ *get_hotkey                 │
├──────────────────────────────┼─────────────────────────────┤
│ *sethotkey                   │ *set_hotkey                 │
├──────────────────────────────┼─────────────────────────────┤
│ *recalculatestat             │ *statuscalc 或 *status_calc │
├──────────────────────────────┼─────────────────────────────┤
│ *copynpc                     │ *dupnpc                     │
└──────────────────────────────┴─────────────────────────────┘


腳本指令說明
------------

*warpparty2 "<目標地圖名稱>",<x>,<y>,<隊伍編號>,{"<來自的地圖名稱>"};

用法和 warpparty 一樣, 都是將指定隊伍的全部隊員統一傳送到指定的目的地. 如果指定了最后一個參數, 那么只有位于“來自的地圖名稱”的隊員會被傳送.

兩者之間的區別在于: 
	warpparty 對已經死亡的隊友則無效(死亡的隊友會被留在原地), 而 warpparty2 對已經死亡的隊友有效(會被立刻以 1HP 的血量复活, 并一起被傳送走).

---------------------------------------

*getheaddir({<角色編號>});

獲取角色的腦袋朝向

朝向編號:
	0為正前方
	1為向右看
	2為向左看

返回值:
	腦袋朝向

---------------------------------------

*getbodydir({<角色編號>});

獲取角色身体的朝向

朝向編號:
	DIR_NORTH 北 
	DIR_NORTHWEST 西北 
	DIR_WEST 西 
	DIR_SOUTHWEST 西南 
	DIR_SOUTH 南 
	DIR_SOUTHEAST 東南 
	DIR_EAST 東 
	DIR_NORTHEAST 東北

返回值:
	身体朝向

---------------------------------------

*setheaddir <朝向編號>{,<角色編號>};

用于調整角色的腦袋朝向.

朝向編號:
	0為正前方
	1為向右看
	2為向左看

---------------------------------------

*setbodydir <朝向編號>{,<角色編號>};

用于調整角色身体的朝向.

朝向編號:
	DIR_NORTH 北 
	DIR_NORTHWEST 西北 
	DIR_WEST 西 
	DIR_SOUTHWEST 西南 
	DIR_SOUTH 南 
	DIR_SOUTHEAST 東南 
	DIR_EAST 東 
	DIR_NORTHEAST 東北

---------------------------------------

*party_leave {<角色編號>};

用于讓指定的角色立刻退出隊伍.

返回值:
	若指定角色不在線或不在隊伍中, 則返回 0, 成功則返回 1

---------------------------------------

*openbank {<角色編號>};

用于讓指定的角色立刻打開銀行界面(只對擁有賬號隨身銀行的客戶端版本有效).

返回值:
	若指定角色不在線, 則返回 0, 成功則返回 1

---------------------------------------

*instance_users <副本的實例編號>;

用于獲取指定的副本實例中的參与人數.

返回值:
	成功直接返回副本中的人數, 副本不存在或副本中無人存在則返回 0

---------------------------------------

*mesclear;

清空當前NPC的對話框內容, 借此你可以在無需玩家點擊"Next"按鈕的情況下, 使用 mes 指令來刷新對話窗口的內容.

---------------------------------------

*cap_value <數值>,<最小值>,<最大值>;

用來确保數值變量不會低于最小值, 超過最大值. 

返回值:
	如果低于最小值則直接返回最小值, 如果超過最大值則直接返回最大值, 如果在兩者之間則原樣返回數值.

---------------------------------------

*mobremove <魔物的GID>;

根据GID移除一個魔物(只是移除, 不會讓魔物死亡), 合适用來編寫副本劇情.

---------------------------------------

*getsameipinfo {<"IP地址">};

獲得某個IP在線的玩家數以及玩家的角色編號等信息.

如果執行成功的話, 會賦予以下數組在線玩家的信息:

$@sameip_aid[]		使用指定IP在線的玩家賬號編號數組(AccountID)
$@sameip_cid[]		使用指定IP在線的玩家角色編號數組(CharID)
$@sameip_name$[]	使用指定IP在線的玩家角色名數組

$@sameip_amount 目前使用指定IP登錄的玩家個數.

---------------------------------------

*logout <登出理由編號>{,"<角色名稱>"|<賬號編號>|<角色編號>};

使指定的角色立刻登出游戲(踢下線), 這里的"登出理由編號"只能做參考, 不同的理由編號會讓客戶端給玩家顯示不同的提示文本(下面的信息會在以后漢化):

	0 = BAN_UNFAIR
	1 = server closed -> MsgStringTable[4]
	2 = ID already logged in -> MsgStringTable[5]
	3 = timeout/too much lag -> MsgStringTable[241]
	4 = server full -> MsgStringTable[264]
	5 = underaged -> MsgStringTable[305]
	8 = Server sill recognizes last connection -> MsgStringTable[441]
	9 = too many connections from this ip -> MsgStringTable[529]
	10 = out of available time paid for -> MsgStringTable[530]
	11 = BAN_PAY_SUSPEND
	12 = BAN_PAY_CHANGE
	13 = BAN_PAY_WRONGIP
	14 = BAN_PAY_PNGAMEROOM
	15 = disconnected by a GM -> if( servicetype == taiwan ) MsgStringTable[579]
	16 = BAN_JAPAN_REFUSE1
	17 = BAN_JAPAN_REFUSE2
	18 = BAN_INFORMATION_REMAINED_ANOTHER_ACCOUNT
	100 = BAN_PC_IP_UNFAIR
	101 = BAN_PC_IP_COUNT_ALL
	102 = BAN_PC_IP_COUNT
	103 = BAN_GRAVITY_MEM_AGREE
	104 = BAN_GAME_MEM_AGREE
	105 = BAN_HAN_VALID
	106 = BAN_PC_IP_LIMIT_ACCESS
	107 = BAN_OVER_CHARACTER_LIST
	108 = BAN_IP_BLOCK
	109 = BAN_INVALID_PWD_CNT
	110 = BAN_NOT_ALLOWED_JOBCLASS
	? = disconnected -> MsgStringTable[3]

---------------------------------------

*searcharray <數組變量>,<要查詢的內容>;

查詢數組中第一次出現待查詢內容的索引序號, 使用它來搜索數組內容很方便(用法比較丰富, 以后再舉例細說).

返回值:
	若查不到結果則返回 -1, 否則返回大于等于 0 的序號

---------------------------------------

*getinventorylist {<角色編號>,<類型>};
*getcartlist {<角色編號>,<類型>};
*getstoragelist {<角色編號>,<類型>};

返回背包、手推車、倉庫清單。

在原來返回的數組基礎上, BetterRa 新增了以下返回數組:

	- @inventorylist_idx[] 背包位置序號.
	- @inventorylist_uid$[] 裝備唯一編號(字符串類型數組).
	- @inventorylist_favorite[] 是否被玩家收藏.
	- @inventorylist_equipswich[] 快速切換裝備的位置.

類型: 因每次獲取清單都會有大量的變量被賦值, 經常調用會導致服務器卡頓問題, 
      特添加返回類型, 可通過 | 運算返回多組數据
	  
	- INV_ID           物品ID - @inventorylist_id[]
	- INV_AMOUNT       物品數量 - @inventorylist_amount[]
	- INV_EQUIP        現裝備位置 - @inventorylist_equip[]
	- INV_REFINE       精煉等級 - @inventorylist_refine[]
	- INV_IDENTIFY     是否鑒定 - @inventorylist_identify[]
	- INV_ATTRIBUTE    屬性 - @inventorylist_attribute[]
	- INV_EXPIRE       租賃時間 - @inventorylist_expire[]
	- INV_BOUND        綁定 - @inventorylist_bound[]
	- INV_CARD         卡片 - @inventorylist_card[]
	- INV_OPTION       隨机屬性 - @inventorylist_option_id[] @inventorylist_option_value[] inventorylist_option_parameter[]
	- INV_IDX          位置序列 - @inventorylist_idx[]
	- INV_FAVORITE     是否收藏 - @inventorylist_favorite[]
	- INV_UID          物品UID - @inventorylist_uid$[] 或 @inventorylist_uid[]
	- INV_TRADABLE     是否可交易 - @inventorylist_tradable[]
	- INV_EQUIPSWITCH  切換位置 - @inventorylist_equipswich[]
	- INV_ALL          獲取所有(默認)

例: 獲取背包物品id、數量和背包中的序列
	getinventorylist getcharid(0),INV_ID|INV_AMOUNT|INV_IDX;

注意:
	背包位置序號每一次登錄、每一次玩家在自己的背包中增刪物品(包括但不限: 
	存倉、存手推車、丟棄、購買和使用道具等操作)都可能會導致背包位置序號有變化. 
	所以請注意在一段連續、玩家不可能會停下來做其他動作的腳本中去使用“背包位置序號”. 
	否則, 只要你在 getinventorylist 之后, 還給玩家空隙去進行道具的增刪, 
	那么 @inventorylist_idx[] 中的數据將不再可靠.
	
---------------------------------------

*searchinventory <物品ID>{,<條件>{,<角色ID>}};
*searchcart <物品ID>{,<條件>{,<角色ID>}};
*searchstorage <物品ID>{,<條件>{,<倉庫ID>{,<角色ID>}}};
*searchguildstorage <物品ID>{,<條件>{,<角色ID>}};

過濾并查找背包、手推車、倉庫中的物品.

條件: (多個條件相加或使用与運算)
	- 1  未精煉過的道具
	- 2  非租賃道具
	- 4  非綁定道具
	- 8  沒有卡片和附魔的道具
	- 16 沒有隨机屬性標簽的道具

返回數組:
	- @inventorylist_idx[] 背包位置序號
	- @inventorylist_amount[] 背包中的數量
	- @inventorylist_count 上面數組的成員數
	
例: 
	searchinventory 501,1|2|4|8|16;
	
返回值:
	操作成功返回物品在背包中的總數量 (@inventorylist_amount[]的和)
	當倉庫被占用或找不到倉庫則返回 -1

---------------------------------------

*delinventory <背包位置序號>,<要移除的數量>;

移除指定背包序號指定數量的道具. 

這里的背包位置序號可以通過 getinventorylist 腳本指令的 @inventorylist_idx[] 數組來獲得.

返回值:
	操作成功則返回 1, 失敗或沒那么多道具可以刪則返回 0

---------------------------------------

*countinventory <背包位置序號>;

根据指定背包序號, 獲取該道具在背包中的數量.

返回值:
	直接返回物品的數量, 若改背包序號的物品不存在則返回 0

---------------------------------------

*identifybyidx <背包位置序號>;

根据指定的背包序號, 對該道具進行鑒定操作.

---------------------------------------

*equipinventory <背包位置序號>;

穿戴指定背包位置的裝備.

這里的背包位置序號可以通過 getinventorylist 腳本指令的 @inventorylist_idx[] 數組來獲得.

返回值:
	操作操作成功則返回 1, 失敗則返回 0

---------------------------------------

*unequipinventory <背包位置序號>;

脫下指定背包位置的裝備.

這里的背包位置序號可以通過 getinventorylist 腳本指令的 @inventorylist_idx[] 數組來獲得.

返回值:
	操作操作成功則返回 1, 失敗則返回 0

---------------------------------------

*getinventoryinfo <背包位置序號>,<要查看的信息類型>{,<角色ID>};
*getcartinfo <手推車位置序號>,<要查看的信息類型>{,<角色ID>};
*getstorageinfo <倉庫位置序號>,<要查看的信息類型>{,<倉庫ID>{,<角色ID>}};
*getguildstorageinfo <倉庫位置序號>,<要查看的信息類型>{,<角色ID>};

查看背包、手推車、倉庫、公會倉庫相應位置的道具信息.

這里的背包位置序號可以通過 getinventorylist 腳本指令的 @inventorylist_idx[] 數組來獲得.

要查看的信息類型:
	0 	- 物品編號
	1 	- 堆疊數量
	2 	- 裝備的穿戴位置(如果為 0 則表示還沒穿戴在身上, 位置請參考 EQP_* 開頭的常量)
	3 	- 精煉值
	4 	- 是否已經鑒定(1為已鑒定, 0為未鑒定)
	5 	- 屬性(說是屬性, 其實最常用是用來判斷物品是否損坏, 若損坏則返回1, 沒坏則返回 0)
	6 	- 第一個卡槽的卡片編號
	7 	- 第二個卡槽的卡片編號
	8 	- 第三個卡槽的卡片編號
	9 	- 第四個卡槽的卡片編號
	10	- 過期時間(Unix時間戳, 0 表示永不過期)
	11	- 綁定類型
	12	- 裝備的唯一編號(unique_id)
	13	- 裝備的換裝穿戴位置(equipSwitch)
	16  - 是否被玩家收藏.

	
	.@uid$ = getinventoryinfo(背包序號, 11);	
	.@uid = getinventoryinfo(背包序號, 11);		
	
返回值:
	失敗則返回 -1, 成功則返回你所查詢的信息的值

---------------------------------------

*putcartbyidx <背包位置序號>,<數量>{,<是否触發事件>{,<角色ID>}};
*putstoragebyidx <背包位置序號>,<數量>{,<倉庫ID>{,<是否触發事件>{,<角色ID>}}};
*putguildstoragebyidx <倉庫位置序號>,<數量>{,<是否触發事件>{,<角色ID>}};

將背包中的物品放入手推車、倉庫或公會倉庫 

是否触發事件,為全局事件 OnPCStorageAddFilter OnPCCartAddFilter OnPCCartAddFilter, 默認触發。

返回值:
	成功返回 1, 失敗返回 0

---------------------------------------

*getcartbyidx <手推車位置序號>,<數量>{,<是否触發事件>{,<角色ID>}};
*getstoragebyidx <倉庫位置序號>,<數量>{,<倉庫ID>{,<是否触發事件>{,<角色ID>}}};
*getguildstoragebyidx <倉庫位置序號>,<數量>{,<是否触發事件>{,<角色ID>}};

將手推車、倉庫或公會倉庫的物品拿到背包中

返回值:
	成功返回 1, 失敗返回 0

---------------------------------------

*delinventorybyidx <背包位置序號>,<數量>{,<是否触發事件>{,<角色ID>}};
*delcartbyidx <手推車位置序號>,<數量>{,<是否触發事件>{,<角色ID>}};
*delstoragebyidx <倉庫位置序號>,<數量>{,<倉庫ID>{,<是否触發事件>{,<角色ID>}}};
*delguildstoragebyidx <倉庫位置序號>,<數量>{,<是否触發事件>{,<角色ID>}};

將背包、手推車、倉庫或公會倉庫中的物品刪除

返回值:
	成功返回 1, 失敗返回 0

---------------------------------------

*viewequip <對方的賬號編號>{,<是否強制查看>};

查看指定賬號在線角色的裝備信息(這里只需要提供賬號編號, 程序會根据賬號編號找到他目前在線的角色).

是否強制查看:
	0	- 如果對方禁止其他玩家查看裝備, 那么就不查看
	1	- 就算對方禁止其它玩家查看他的裝備, 也強制進行查看

返回值:
	若指定的目標不在線則返回 -1, 若查看成功則返回 1, 若查看失敗(比如對方禁止查看)則返回 0

---------------------------------------

*itemexists <物品編號>;
*itemexists "物品名稱";
*existitem <物品編號>;
*existitem "物品名稱";

确認服務器的 item_db 中是否存在指定物品, 在由玩家輸入一些物品編號來執行功能時, 先使用該指令判斷一下可以防止直接 getitem 或者 delitem 導致地圖服務器終端顯示報錯信息.

返回值:
	若服務器中不存在此道具則返回0, 若物品存在且可疊加則返回"正數"的物品編號, 若不可堆疊則返回"負數"的物品編號.

---------------------------------------

*setrenttime <裝備位置編號>,<增減的時間秒數>{,<角色編號>};
*resume <裝備位置編號>,<增減的時間秒數>{,<角色編號>};

增加/減少指定位置裝備的租賃時間(如果要減少租賃時間的話, 第二個參數請使用負數).

裝備位置編號: 是指 EQI_* 開頭的位置常量.

返回值:
	如果指定的裝備位置無效或者沒有裝備則返回 -1, 返回 0 表示此物品不是租賃道具(永不過期), 如果返回大于 0 的數則表示此物品是租賃道具(返回值就是它被您增減時間之后, 剩余時間的秒數)	

---------------------------------------

*battleignore <開關標記>{,<角色編號>};

將指定的角色設置為魔物無視狀態(魔物會無視此玩家的存在, 因此不會攻擊該玩家, 或許可以叫無敵狀態), 避免被魔物攻擊.

開關標記:
	0 關閉無視(角色會被魔物看見), 1 打開無視(角色不會被魔物看見, 也不會被攻擊)

---------------------------------------

*getequipexpiretick <裝備位置編號>{,<角色編號>};
*isrental <裝備位置編號>{,<角色編號>};

獲得指定位置裝備的租賃到期剩余秒數.

返回值:
	如果指定的裝備位置無效或者沒有裝備則返回 -1, 返回 0 表示此物品不是租賃道具(永不過期), 如果返回大于 0 的數則表示此物品是租賃道具(返回值就是它剩余時間的秒數)	

---------------------------------------

*sc_check <狀態編號>{,<gid>};

用于判斷指定的狀態(Buff)是否存在, 并取得狀態參數.

當返回值為1的時候, 可以通過以下變量來讀取狀態的參數:

@sc_val1		狀態的第1個參數(如果是技能對應的狀態的話, 往往這個參數都是技能等級)
@sc_val2		狀態的第2個參數
@sc_val3		狀態的第3個參數
@sc_val4		狀態的第4個參數
@sc_tickleft	狀態的剩余時間(單位為毫秒)

返回值:
	0 表示玩家身上沒有你指定的狀態(Buff), 1 表示玩家身上擁有你指定的狀態(Buff)

---------------------------------------

*when_pcmove_doevent;

當玩家的角色在下一次移動時, 触發 OnPCMoveFilter 事件.

注意: 只有當 conf/battle/extend.conf 的 pc_move_event_trigger_type 選項為 1 時, 該腳本指令才會有价值.

---------------------------------------

*processhalt;
*halt;

在部分支持的事件處理腳本中使用后, 能夠在事件腳本結束時, 中斷源代碼的后續邏輯. 
此功能僅供腳本專家們使用, 沒弄明白它的工作邏輯之前, 請慎重使用.

真心話:
	由于事件隊列机制的影響, 這個功能遠比想象的要雞肋, 只是為了兼容一下 SeAr, 能不用就盡量別用吧.

該指令特定情況下會失效:
	該指令的使用流程中, 在使用 processhalt 之前不能出現 sleep、sleep2、next、close2、menu、
	select、prompt、input、progressbar 等會導致腳本暫停的指令, 否則它的中斷效果將失效.
	
	主要原因是: 如果你執行了這些指令, 那么服務端需要等待客戶端或者玩家做出響應, 
	而一旦出現這种情況服務端會立刻將此事件認為“執行告一段落”, 然后就立刻去判斷是否需要中斷, 
	但是由于你 processhalt 寫在了這些會導致腳本暫停的指令后面, 
	所以在還沒來得及執行 processhalt 的時候服務端就會認為不需要中斷而結束.

失效可能會帶來效果錯亂:
	此外如果錯誤的使用了 processhalt 的執行順序, 也會影響到下一次此事件的触發效果,
	下一次触發此事件時不管是否執行過 processhalt, 都會被認為需要中斷.

事件隊列机制的影響說明:
	舉個例子, 我們可能需要使用 processhalt 在特定的情況下中斷 OnPCEquipFilter 事件,
	以達到禁止玩家穿戴裝備的目的. 但是只這么做是不完善的,  在特定情況下可能完全失效.
	
	為了避免一個玩家同時執行多個腳本帶來的沖突, rAthena 的腳本引擎實現了一個“事件隊列”功能,
	此功能能夠當玩家在執行某個腳本的時候, 將接下來可能需要玩家執行的腳本預先存放到隊列里面,
	等玩家執行完上個腳本再繼續触發執行下一個腳本的內容.
	
	這將導致出現一种情況, 如果玩家在和 NPC 對話的情況下去穿戴裝備的話, 
	那么此時 OnPCEquipFilter 事件將會被放進隊列中而不會立刻執行. 
	您的腳本代碼無法對 OnPCEquipFilter 事件進行 processhalt 處理, 
	進而地圖服務器會認為玩家穿戴裝備這個事情沒有被中斷, 而允許成功穿戴裝備.

支持的事件以及其中斷作用說明請見: doc\BetterRa_events.txt

---------------------------------------

*script4each "{<腳本>}",<覆蓋范圍>{,<參數>...};
*script4each "NPCNAME::EVENT",<覆蓋范圍>{,<參數>...};
*script4eachmob "{<腳本>}",<覆蓋范圍>{,<參數>...};
*script4eachmob "NPCNAME::EVENT",<覆蓋范圍>{,<參數>...};
*script4eachnpc "{<腳本>}",<覆蓋范圍>{,<參數>...};
*script4eachnpc "NPCNAME::EVENT",<覆蓋范圍>{,<參數>...};

對指定范圍的玩家、魔物、NPC執行相同的一段腳本，在"{<腳本>}或NPCNAME::EVENT"中使用 $@gid 來獲取和腳本關聯的玩家、魔物、NPC的 GID. 陣營魔物同樣可以使用本指令.

全服				  - script4each "{<腳本>}或NPCNAME::EVENT",0;
指定地圖			- script4each "{<腳本>}或NPCNAME::EVENT",SFE_MAP,"地圖名";
指定區域			- script4each "{<腳本>}或NPCNAME::EVENT",SFE_MAP_RANGE,"地圖名",中心坐標x,中心坐標y,范圍;
指定地圖上的隊伍	- script4each "{<腳本>}或NPCNAME::EVENT",SFE_MAP_PARTY,"地圖名",隊伍編號;
指定地圖上的公會	- script4each "{<腳本>}或NPCNAME::EVENT",SFE_MAP_GUILD,"地圖名",公會編號;
指定區域			- script4each "{<腳本>}或NPCNAME::EVENT",SFE_MAP_AREA,"地圖名",坐標x0,坐標y0,坐標x1,坐標y1;
指定隊伍			- script4each "{<腳本>}或NPCNAME::EVENT",SFE_PARTY,隊伍編號;
指定公會			- script4each "{<腳本>}或NPCNAME::EVENT",SFE_GUILD,公會編號;
指定地圖上的陣營	- script4each "{<腳本>}或NPCNAME::EVENT",SFE_MAP_TRIBE,"地圖名",Tribe陣營編號;
指定陣營			- script4each "{<腳本>}或NPCNAME::EVENT",SFE_TRIBE,Tribe陣營編號;
指定地圖上的陣營	- script4each "{<腳本>}或NPCNAME::EVENT",SFE_MAP_BG,"地圖名",BG陣營編號;
指定陣營			- script4each "{<腳本>}或NPCNAME::EVENT",SFE_BG,BG陣營編號;

例:
	script4eachmob "{unittalk $@gid,\"123456\";}",1,"prontera";

	等价于
	script4eachmob "NPCNAME::OnTalk",1,"prontera";
	end;
OnTalk:
	unittalk $@gid,"123456";

注意: 
	如果<腳本>中有使用到大括號的話, 需要在大括號的左側使用 \ 來進行轉義, 例如:
	script4each "{ if (BaseLevel >= 10) \{ getitem 501, 10;\} }",0;

警告:
	目前 script4each 所執行的腳本中, 禁止出現會導致腳本進入暫停狀態的指令.
	比如 sleep、sleep2、next、close2、menu、select、prompt、input、progressbar 等, 他們的特點是執行這些指令時, 
	都需要等待客戶端/玩家返回一定的信息或做出選擇才能繼續往下執行.

---------------------------------------

*gethotkey <快捷鍵位置編號>{,<要獲取的數据類型>};
*get_hotkey <快捷鍵位置編號>{,<要獲取的數据類型>};

獲取指定快捷鍵位置的信息, 快捷鍵位置編號必須大于 0 小于等于 MAX_HOTKEYS (這是個常量, 腳本中可以直接使用).

要獲取的數据類型:
	0	- 獲取快捷鍵的類型 (0 表示該位置的快捷鍵上放的是一個物品, 1 表示該位置的快捷鍵上放的是一個技能)
	1	- 獲取技能編號或物品的編號
	2	- 獲取登記在快捷鍵上的技能等級

返回值:
	如果參數不合法則返回 -1, 否則返回的是你想要獲取的數据內容

---------------------------------------

*sethotkey <快捷鍵位置編號>,<快捷鍵的類型>,<物品編號/技能編號>,<技能等級>;
*set_hotkey <快捷鍵位置編號>,<快捷鍵的類型>,<物品編號/技能編號>,<技能等級>;

設置玩家快捷鍵上的內容, 快捷鍵位置編號必須大于 0 小于等于 MAX_HOTKEYS (這是個常量, 腳本中可以直接使用).

快捷鍵的類型:
	0	- 這個快捷鍵位置想放置一個物品 (若使用該值, 則最末尾的"技能等級"參數無意義, 請直接給"技能等級"參數傳 0 )
	1	- 這個快捷鍵位置想放置一個技能

返回值:
	設置成功則返回 1, 設置失敗則返回 0

---------------------------------------

*bonus_script_remove "<要移除的腳本代碼>"{,<角色編號>};

移除指定的 bonus_script 效果

---------------------------------------

*setpolicyid <行為策略編號>{,<角色編號>};

設置指定玩家的行為策略編號, 配合 conf/policies.conf 中定義的規則來使用.

行為策略編號:
	即在 conf/policies.conf 定義的 policy_id 編號.

返回值:
	設置成功則返回 1, 設置失敗則返回 0

---------------------------------------

*getpolicyid {<角色編號>};

獲得指定玩家的行為策略編號, 配合 conf/policies.conf 中定義的規則來使用.

返回值:
	設置成功則返回行為策略編號, 設置失敗則返回 -1

---------------------------------------

*getpolicyinfo <行為策略信息編號>{,<角色編號>};

獲得指定玩家當前的行為策略詳情, 配合 conf/policies.conf 中定義的規則來使用.

行為策略信息編號(与 conf/policies.conf 中的字段對應):
	0	- base_exp_rate
	1	- job_exp_rate
	2	- drop_rate
	3	- look_head_top
	4	- bind_group_id

返回值:
	成功則獲得你想要查詢的信息的值, 失敗則返回 -1

---------------------------------------

*setchartitle <稱號ID>{,<角色編號>};

設置指定玩家的稱號ID, 該指令只在客戶端版本號大于等于 20150513 的時候有效.

稱號ID:
	這個稱號的ID在客戶端的 data\luafiles514\lua files\datainfo\titletable.lub 中獲取. 例如: 1000

返回值:
	設置成功則返回 1, 設置失敗則返回 0

---------------------------------------

*getchartitle {<角色編號>};

獲得指定玩家的稱號ID, 該指令只在客戶端版本號大于等于 20150513 的時候有效.

返回值:
	設置成功則返回目標玩家的稱號ID(若為 0 則表示此玩家沒有稱號), 設置失敗則返回 -1

---------------------------------------

*query_multidb "拓展數据庫的連接名稱","SQL查詢語句"{, <數組變量1>{, <數組變量2>{, ...}}};

對拓展數据庫執行SQL查詢, 用法和 query_sql 類似, 只是多了一個"拓展數据庫的連接名稱"參數, 用來指定要操作的拓展數据庫.

拓展數据庫的定義:
	在默認情況下, rAthena 提供的腳本指令只能操作主數据庫(query_sql)和日志數据庫(query_logsql), 但如果我們需要操作第三個數据庫(比如 DiscuzX 論壇數据庫) 的時候, rAthena 自帶的指令就無能為力了. 為了拓展腳本的能力, BetterRa 能夠允許你通過 conf/multidb_athena.conf 配置文件來定義拓展數据庫, 并使用 query_multidb 對其進行操作.

返回值:
	与 query_sql、query_logsql 類似, 不再敷述

---------------------------------------

*recalculatestat;
*statuscalc;
*status_calc;

該指令的原名 recalculatestat 是 rAthena 的官方自帶腳本指令, 在此為了兼容一些腳本, 賦予了 statuscalc 和 status_calc 兩個別名給它.

---------------------------------------

*getequipidx <裝備位置編號>,{<角色編號>};

用來獲取穿戴在指定位置的裝備的“背包位置序號”.

注意: “裝備位置編號”和 getequipid 一樣, 是 EQI_* 開頭的常量(而不是 EQP_* 開頭的常量).

返回值:
	-1	- 在指定的位置找不到裝備
	-2	- 裝備位置編號無效
	其他大于等于 0 的數值, 則表示成功, 返回值就是所查位置裝備的“背包位置序號”.

---------------------------------------

*bounditembyidx <背包序號>,<綁定類型>{,<角色ID>};
*bounditembypos <裝備編號>,<綁定類型>{,<角色ID>};

綁定 背包序號/裝備編號 指定道具的道具

綁定類型: 
	BOUND_NONE    不綁定
	BOUND_ACCOUNT 賬號綁定
	BOUND_GUILD   公會綁定
	BOUND_PARTY   隊伍綁定
	BOUND_CHAR    角色綁定
	
---------------------------------------

*setoptionbyidx <背包序號>,<Random Option ID數組>,<Random Option value數組>,<Random Option param數組>;
*setoptionbypos <裝備編號>,<Random Option ID數組>,<Random Option value數組>,<Random Option param數組>;

設置 背包序號/裝備編號 指定道具的 Random Option 屬性.

裝備編號: 是指 EQI_* 開頭的位置常量.

此選項會在 picklog 日志表中留下道具的變化痕跡.

---------------------------------------

*resetoptionbyidx <背包序號>;
*resetoptionbypos <裝備編號>;

清空 背包序號/裝備編號 指定物品的 Random Option 內容.

此選項會在 picklog 日志表中留下道具的變化痕跡.

返回值:
	操作成功則返回 1, 失敗則返回 0

---------------------------------------

*getoptionbyidx <背包序號>;
*getoptionbypos <裝備編號>;

獲取 背包序號/裝備編號 指定道具的 Random Option 屬性的值.

調用指令后, 裝備的 Random Option 屬性的值保存在三個數組中 @option_id @option_value @option_param

---------------------------------------

*getidxrandomoption(<背包序號>,<Random Option序號>,<要修改的數据類型>{,<角色編號>});
*getposrandomoption(<裝備編號>,<Random Option序號>,<要修改的數据類型>{,<角色編號>});

獲取 背包序號/裝備編號 指定道具的 Random Option 屬性的值.

裝備編號: 是指 EQI_* 開頭的位置常量.

要修改的數据類型:
	ROA_ID - 隨机屬性的ID, 要和 db/re/item_randomopt_db.txt 中的對應
	ROA_VALUE - 隨机屬性的值
	ROA_PARAM - 隨机屬性的參數(這個參數的作用取決于item_randomopt_db.txt中如何使用ROA_PARAM, 目前看來所有官方的隨机屬性都沒有用到這個參數)

返回值:
	操作成功則返回查詢的值, 失敗則返回 -1, 如果因為請求的<類型>無效而失敗則返回 0

---------------------------------------

*setidxrandomoption(<背包序號>,<Random Option序號>,<id>,<value>,<param>{,<角色編號>});
*setposrandomoption(<裝備編號>,<Random Option序號>,<id>,<value>,<param>{,<角色編號>});

設置 背包序號/裝備編號 指定道具的 Random Option 屬性.

裝備編號: 是指 EQI_* 開頭的位置常量.

如果被設定的道具未被穿戴, 那么會先告訴客戶端該道具被刪除, 
然后完成對道具的屬性修改后, 再告訴客戶端你獲得了一個新道具, 此時聊天欄會有個提示.

如果被設定的道具已被穿戴, 那么會先將裝備脫下, 然后告訴客戶端該道具被刪除, 
接著完成對道具的屬性修改后, 再告訴客戶端你獲得了一個新道具, 并自動將裝備穿戴上.

該道具的背包序號不會因為該指令的操作而被修改.

此選項會在 picklog 日志表中留下道具的變化痕跡.

返回值:
	操作成功則返回 1, 失敗則返回 0

---------------------------------------

*getiteminfo(<物品編號>,<類型>)

在原來類型的基礎上, BetterRa 新增了以下類型:

17 - 是否可精煉, 1表示可以精煉, 0表示不能精煉
18 - 交易限制掩碼, 將返回該物品在 item_trade 數据庫中第二列定義的值
19 - 不會因玩家主動使用而被消耗, 1表示是, 0表示否
20 - 不會被技能當做消耗品而消耗, 1表示是, 0表示否
21 - 是否為寵物捕捉道具, 0表示否, 若是則返回能捕獲的魔物編號
22 - 是否在其使用腳本中調用了 callfunc 指令, 1表示是, 0表示否 (复興前版本返回 -1)

---------------------------------------

*duplicate("<复制出來的新NPC所在地圖名稱>,<X坐標>,<Y坐標>,<朝向編號>","duplicate(<來源NPC名稱>)","<复制出來的新NPC名稱>","<角色編號>");
*duplicate("<复制出來的新NPC所在地圖名稱>,<X坐標>,<Y坐標>,<朝向編號>%TAB%duplicate(<來源NPC名稱>)%TAB%<复制出來的新NPC名稱>%TAB%<角色編號>");
*copynpc("<复制出來的新NPC所在地圖名稱>,<X坐標>,<Y坐標>,<朝向編號>","duplicate(<來源NPC名稱>)","<复制出來的新NPC名稱>","<角色編號>");
*copynpc("<复制出來的新NPC所在地圖名稱>,<X坐標>,<Y坐標>,<朝向編號>%TAB%duplicate(<來源NPC名稱>)%TAB%<复制出來的新NPC名稱>%TAB%<角色編號>");
*dupnpc("<复制出來的新NPC所在地圖名稱>,<X坐標>,<Y坐標>,<朝向編號>","duplicate(<來源NPC名稱>)","<复制出來的新NPC名稱>","<角色編號>");

將一個指定的NPC复制到一個新的位置.
主要的參數是4個字符串, 這四個字符串与使用 duplicate 進行靜態复制時候的四個用 %TAB% 分隔的內容是一樣的.
腳本指令可以將NPC复制到副本中, 复制到副本中名稱會改變, 請使用 instance_npcname 獲得NPC的真實名稱.

假設有以下NPC, 我們想把它复制一個新的出來:

	prontera,146,99,2    script    PVP管理員::PVPCOPYTEST    917,{
		mes "[PVP管理員]";
		mes "場地正在修理, 請稍后再來...";
		close;
	}

通常的做法是在腳本中, 使用 duplicate 指令進行靜態复制, 如:

	prontera,156,99,2	duplicate(PVPCOPYTEST)	PVP管理員#1	917

現在你可以使用 copynpc 腳本指令, 將上面這一行靜態复制代碼按 %TAB% 分割為4個字段, 然后以字符串形式傳遞給 copynpc 腳本指令, 如:

	copynpc "prontera,156,99,2","duplicate(PVPCOPYTEST)","PVP管理員#1","917";

同時此函數支持返回复制出來的新NPC的GID, 方便你使用 unit 系列指令對其進行操作, 如:
	
	.@gid = copynpc("prontera,156,99,2	duplicate(PVPCOPYTEST)	PVP管理員#1	917");
	.@gid = copynpc("prontera,156,99,2","duplicate(PVPCOPYTEST)","PVP管理員#1","917");
	unittalk .@gid, "My GID is : " + .@gid;
	
如何在副本中使用:

	.@w1 = instance_mapname("1@tower") + ",156,99,2";
	.@w2 = "duplicate(PVPCOPYTEST)";
	.@w3 = "PVP管理員::123";
	.@w4 = "917";
	
	copynpc .@w1, .@w2, .@w3, .@w4;
	npctalk "我是复制自 PVPCOPYTEST 的NPC", instance_npcname("PVPCOPYTEST::123");
	
注意: 1. NPC名稱中必須帶有 ::XXX 才能复制成功, XXX最好為數字
	  2. 當在副本中复制多個相同的NPC時, 通過修改 ::XXX 來避免NPC名稱重复
	  3. 可以通過 instance_npcname("來源NPC名稱::XXX"); 獲取NPC的真實名稱. 
 
	// 复制相同源生成的NPC
	copynpc instance_mapname("1@tower") + ",156,100,2", "duplicate(PVPCOPYTEST)", "PVP管理員::1", "917";
	copynpc instance_mapname("1@tower") + ",156,101,2", "duplicate(PVPCOPYTEST)", "PVP管理員::2", "917";
	copynpc instance_mapname("1@tower") + ",156,102,2", "duplicate(PVPCOPYTEST)", "PVP管理員::3", "917";
	copynpc instance_mapname("1@tower") + ",156,103,2", "duplicate(PVPCOPYTEST)", "PVP管理員::4", "917";
	sleep 3000;
	// 移除相同源生成的NPC
	unloadcopynpc instance_npcname("PVPCOPYTEST::1");
	unloadcopynpc instance_npcname("PVPCOPYTEST::2");
	unloadcopynpc instance_npcname("PVPCOPYTEST::3");
	unloadcopynpc instance_npcname("PVPCOPYTEST::4");

返回值:
	复制成功, 則返回复制出來的新NPC的GID, 失敗則返回 0

---------------------------------------

*unloadduplicate "<NPC名稱>";
*unloadcopynpc "<NPC名稱>";

卸載掉复制的NPC, 具体使用方法請查看指令 copynpc

如果是副本中的NPC請先用 instance_npcname 指令返回NPC名字, 也可以通過 strnpcinfo(3) 獲取NPC名稱.

---------------------------------------

*getareagid("<地圖名>",<查詢的單位類型>,<x0>,<y0>,<x1>,<y1>,<返回數組>);
*getareagid("<地圖名>",<查詢的單位類型>,<中心坐標x>,<中心坐標y>,<半徑>,<返回數組>);
*getareagid("<地圖名>",<查詢的單位類型>,<返回數組>);

當地圖名為 this 時, 表示為執行腳本的玩家所在的地圖, 此時腳本必須關聯玩家.

查詢的單位類型:
	BL_PC		- 玩家單位
	BL_MOB		- 魔物單位
	BL_PET		- 寵物單位
	BL_HOM		- 人工生命体單位
	BL_MER		- 佣兵單位
	BL_ITEM		- 物品單位 (拿到了也暫時用不上)
	BL_SKILL	- 技能單位 (拿到了也暫時用不上)
	BL_NPC		- NPC單位
	BL_CHAT		- 聊天室單位 (拿到了也暫時用不上)
	BL_ELEM		- 元素精靈單位 (拿到了也暫時用不上)

返回數組:
	填寫一個你希望查到的 GID 存儲的數字類型數組的變量名, 比如 .@gids
	
	注意: 這里給定的變量名, 務必要考慮執行該指令的時候, 腳本是否關聯了玩家, 
	如果沒有關聯的話需要使用和玩家無關的變量類型, 比如 $@ 開頭的變量
	
舉個例子:
prontera,150,90,4	script	getareagid_test	123,{
	.@result = getareagid("this", BL_NPC, .@gids);
	if (.@result < 0) {
		dispbottom "執行 getareagid 時發生了錯誤, 返回值為: " + .@result;
	}
	
	for (.@i = 0; .@i < .@result; .@i++) {
		dispbottom ".@gids[" + .@i + "] = " + .@gids[.@i] + " NPC名稱為: " + getunitname(.@gids[.@i]);
	}
}

返回值:
	返回大于 0 的數值: 表示找到了單位, 返回的數值為找到的單位個數
	返回 -1 : 指定地圖為 this 但是沒有關聯玩家
	返回 -2 : 給定的地圖名字是無效的, 找不到地圖
	返回 -3 : 傳遞的參數個數不對, 必須是3個、6個或者7個參數
	返回 -4 : 給定的"返回數組"類型不對, 不能是一個字符串或數值常量, 也不能是字符串數組
	返回 -5 : 給定的"返回數組"是一個需要依賴玩家的變量類型, 但是沒有關聯玩家 (比如 . 或 .@ 開頭的數字類型數組)
	
---------------------------------------

mail_create <發件人名>,<題目>,<內容>{,<ZENY>}
mail_additem、mail_additem2、mail_additem3、mail_additembound、mail_additembound2、mail_additembound3 与相應的getitem指令參數相同
mail_send {<收件人CID 或 收件人名>} 通過CID發送郵件只能發送給在線玩家

發送郵件指令, 注意mail_create\mail_additem*\mail_send 指令必須連續使用.否則有可能造成發送郵件物品錯誤的情況.
當你創建完郵件并添加物品到郵件后, 可以連續使用 mail_send 來進行群發..

---------------------------------------

*sendmail(<收件人角色編號>,"<發送者名稱>","<標題>","<內容>"{,<附件中的金幣>{,<附件一的物品編號>,<附件一的物品數量>{,<附件二的物品編號>,<附件二的物品數量>{,<附件三的物品編號>,<附件三的物品數量>{,<附件四的物品編號>,<附件四的物品數量>{,<附件五的物品編號>,<附件五的物品數量>}}}}}});
*sendmail2(<收件人角色編號>,"<發送者名稱>","<標題>","<內容>"{,<附件中的金幣>{,<附件一的物品編號>,<附件一的物品數量>,<附件一是否已鑒定>,<附件一的精煉值>,<附件一的屬性>,<附件一的第一張卡片>,<附件一的第二張卡片>,<附件一的第三張卡片>,<附件一的第四張卡片>{,<附件二的物品編號>,<附件二的物品數量>,<附件二是否已鑒定>,<附件二的精煉值>,<附件二的屬性>,<附件二的第一張卡片>,<附件二的第二張卡片>,<附件二的第三張卡片>,<附件二的第四張卡片>{,<附件三的物品編號>,<附件三的物品數量>,<附件三是否已鑒定>,<附件三的精煉值>,<附件三的屬性>,<附件三的第一張卡片>,<附件三的第二張卡片>,<附件三的第三張卡片>,<附件三的第四張卡片>{,<附件四的物品編號>,<附件四的物品數量>,<附件四是否已鑒定>,<附件四的精煉值>,<附件四的屬性>,<附件四的第一張卡片>,<附件四的第二張卡片>,<附件四的第三張卡片>,<附件四的第四張卡片>{,<附件五的物品編號>,<附件五的物品數量>,<附件五是否已鑒定>,<附件五的精煉值>,<附件五的屬性>,<附件五的第一張卡片>,<附件五的第二張卡片>,<附件五的第三張卡片>,<附件五的第四張卡片>}}}}}});
*sendmail3(<收件人角色編號>,"<發送者名稱>","<標題>","<內容>"{,<附件中的金幣>{,<附件一的物品編號>,<附件一的物品數量>,<附件一是否已鑒定>,<附件一的精煉值>,<附件一的屬性>,<附件一的第一張卡片>,<附件一的第二張卡片>,<附件一的第三張卡片>,<附件一的第四張卡片>,<附件一的RandomIDArray>,<附件一的RandomValueArray>,<附件一的RandomParamArray>{,<附件二的物品編號>,<附件二的物品數量>,<附件二是否已鑒定>,<附件二的精煉值>,<附件二的屬性>,<附件二的第一張卡片>,<附件二的第二張卡片>,<附件二的第三張卡片>,<附件二的第四張卡片>,<附件二的RandomIDArray>,<附件二的RandomValueArray>,<附件二的RandomParamArray>{,<附件三的物品編號>,<附件三的物品數量>,<附件三是否已鑒定>,<附件三的精煉值>,<附件三的屬性>,<附件三的第一張卡片>,<附件三的第二張卡片>,<附件三的第三張卡片>,<附件三的第四張卡片>,<附件三的RandomIDArray>,<附件三的RandomValueArray>,<附件三的RandomParamArray>{,<附件四的物品編號>,<附件四的物品數量>,<附件四是否已鑒定>,<附件四的精煉值>,<附件四的屬性>,<附件四的第一張卡片>,<附件四的第二張卡片>,<附件四的第三張卡片>,<附件四的第四張卡片>,<附件四的RandomIDArray>,<附件四的RandomValueArray>,<附件四的RandomParamArray>{,<附件五的物品編號>,<附件五的物品數量>,<附件五是否已鑒定>,<附件五的精煉值>,<附件五的屬性>,<附件五的第一張卡片>,<附件五的第二張卡片>,<附件五的第三張卡片>,<附件五的第四張卡片>,<附件五的RandomIDArray>,<附件五的RandomValueArray>,<附件五的RandomParamArray>}}}}}});

使用該指令, 可以給指定的玩家發送一封郵件. 三個不同版本的指令其實只是支持的參數有所不同.

版本區別:
	sendmail 	可以發送簡單的附件(無任何卡片或者精練值的道具, 藥水等)
	sendmail2	可以發送比較复雜的附件(可設定卡片、精煉值等)
	sendmail3	除了卡片和精煉值之外, 還可以支持 Random Options (隨机屬性)

演示腳本:
	關于這一系列的指令使用方法, 可以參考 npc\BetterRa\BetterRa_sendmail.txt 演示腳本

注意事項:
	這一系列的指令不會去嘗試判斷收件人角色編號是否合法, 需要自己做判斷.
	若客戶端不支持RODEX的話, 那么附件只有第一個會有效.

---------------------------------------

getservantgid <類型>{,<角色編號>};

獲得相應類型的跟隨者的GID.

查詢的單位類型:
	BL_PC		- 玩家單位
	BL_PET		- 寵物單位
	BL_HOM		- 人工生命体單位
	BL_MER		- 佣兵單位

---------------------------------------

unitremove <GID>,<特效編號>;

用于移除某個GID實体, 并播放某個動畫.
可以移除:  - 玩家單位
           - 魔物單位
           - 寵物單位
           - 人工生命体單位
           - 佣兵單位
           - 物品單位 (拿到了也暫時用不上)
           - 技能單位 (拿到了也暫時用不上)
           - NPC單位
		   - 元素精靈單位 (拿到了也暫時用不上)
		   
特效編號:  
	0: 沒有特效
	1: 登出特效
	2: 瞬移特效
	3: 死亡特效

---------------------------------------

tribe_setteam <陣營編號>;
tribe_setteam <GID>,<陣營編號>;

設置玩家或魔物的陣營組. 不同的陣營組之間是有仇恨的, 也就是說 魔物和魔物之間可以打, 默認陣營為0;
陣營系統只有在擁有tribe這個 mapflag 標簽的時候才有效

---------------------------------------

tribe_getteam {<GID>};

通過GID獲取某個實体的陣營編號.

---------------------------------------

tribe_mobteam <陣營編號>;

設置通過 monster, areamonster 召喚出來的魔物的陣營編號..必須在monster或areamonster之后使用.

例子:(召喚并設置10個波利為陣營1)
	monster "prontera",0,0,"Quest Poring",1002,10;
	tribe_mobteam 1;

---------------------------------------

tribe_monster <陣營編號>,"<地圖名字>",<x坐標>,<y坐標>,"<魔物名字>",<魔物ID>,"<事件標簽>";

召喚一個怪物并返回新招換的魔物的魔物ID. 可通過 playerattached 判斷是否是玩家殺死的魔物。

事件返回變量:
	
	注意: 因事件在遇到玩家正在運行時會排隊, 所以与玩家關聯時使用全局變量返回值會被其他擊殺覆蓋, 
	如果你開啟了 disable_mobdead_queue 則無需顧慮此問題可以直接使用全局變量
	
	如果是玩家殺死, 則返回:
		killedgid			被殺死魔物的GID
		killedrid			被殺死魔物的魔物編號(MobID)
		killerrid			殺死魔物的實体GID
	
	如果是魔物殺死, 則返回: 
		$killedgid			被殺死魔物的GID
		$killedrid			被殺死魔物的魔物編號(MobID)
		$killerrid			殺死魔物的實体GID

例子:

	tribe_monster .@tribe_id,"prontera",100,100,"Food Depot",1910,"Feed Depot#1::OnMyMobDead";
	end;

	set .@monster_gid, tribe_monster(.@tribe_id,"prontera",100,104,"Guardian",1949,"NPCNAME::OnMyMobDead");
	end;

---------------------------------------

unitsteppath <GID>,"<路點名>"{,<尋路AI>,{<參數>,{<"事件名稱">}}};
unitsteppath <GID>,<路點編號>{,<尋路AI>,{<參數>,{<"事件名稱">}}};

給魔物設置自動行走路徑, 設置自動行走路徑后, 魔物將會按照路徑的坐標一個一個的按照順序走下去,直到走到重點為止.

"<路點名>"\<路點編號> 為 step_path.txt 中的第一個字段.

尋路AI:
	PH_WALKBACK: 离開路徑<參數>格或遇到障礙時, 不再追蹤, 自動行走返回路徑. (默認)
	PH_WARPBACK: 离開路徑直到失去目標后, 傳送回路徑繼續走完路徑.
	PH_IGNOREWALK: 永遠不追蹤目標, 但如果目標在攻擊(拾取)范圍內, 依然會攻擊(拾取).
	PH_IGNOREALL: 永遠不做任何其他事情, 一路走到路點結束.
	PH_ASTARTWALK: 离開路徑后, 調用A*算法計算路徑, 并走到最終規定的路點終點.
	PH_ASTARTWALKBACK: 离開路徑后, 調用A*算法計算返回路徑.

<參數> 默認為 25, 為 PH_WALKBACK 提供返回距离， 當魔物离開路徑 <參數> 格時，魔物不在追蹤返回路徑。
<"事件名稱"> 為路徑點走完以后調用的事件，魔物路徑尋路失敗也會執行此命令, 事件可通過 $@steppath_gid 獲得触發事件魔物的GID, $@steppath_fail 返回到達終點.

---------------------------------------

*bot_login <char_id>;
*bot_login "<玩家名>";
*bot_login <account_id>,<char_id>,<性別>;

	登陸一個數据庫中已有的賬號. 
	登陸過程中, 腳本暫停等待登陸完成后, 腳本關聯會轉移至登陸的BOT賬號
	
返回值:
	返回 BOT 的 AID

---------------------------------------

*bot_adduseskill <技能ID>,<技能等級>{,<使用間隔>{,<优先級>{,<使用條件>{,<參數1>{,<參數2>{,<角色ID>}}}}}};

	添加技能到使用列表, 在滿足條件時, 机器人會自動釋放技能.

使用間隔:
	技能釋放后, 需要間隔多久才能再次釋放.

优先級:
	优先級較高的技能滿足條件會优先釋放.

使用條件:
	always				無條件 ( 默認, 沒有參數 ).
	myhpinrate			當自己的 HP 在限定范圍內 ( 小于 <參數1> 或大于 <參數2> 時 ).
	myspinrate			當自己的 HP 在限定范圍內 ( 小于 <參數1> 或大于 <參數2> 時 ).
	mystatuson			當自己擁有指定狀態時 ( <參數1> 為指定的狀態ID ).
	mystatusoff			當自己失去指定狀態時 ( <參數1> 為指定的狀態ID ).
	friendhpinrate		當隊友(包括自己)的 HP 在限定范圍內 ( 小于 <參數1> 或大于 <參數2> 時 ).
	friendstatuson		當隊友(包括自己)擁有指定狀態時 ( <參數1> 為指定的狀態ID ).
	friendstatusoff		當隊友(包括自己)失去指定狀態時 ( <參數1> 為指定的狀態ID ).
	attackedgt			當攻擊自己的敵人超過指定數量時 ( <參數1> 為攻擊自己的數量 ).
	closedattacked		當被近距离攻擊時 ( 沒有參數 ).
	longrangeattacked	當被遠距离攻擊時 ( 沒有參數 ).
	afterskill			當使用指定技能后 ( <參數1> 為指定的技能ID ).
	mobincount			當可視范圍內魔物數量在限定范圍內 ( 小于 <參數1> 或大于 <參數2> 時 ).
	itemlessthan		當背包中指定物品數量在小于指定數值時 ( 物品ID為 <參數1> 的物品小于 <參數2> 個時 ).

---------------------------------------

*bot_adduseitem <物品ID>{,<使用延時>{,<优先級>{,<使用條件>{,<參數1>{,<參數2>{,<角色ID>}}}}}};

	添加物品到使用列表, 在滿足條件時, 机器人會自動使用物品.

使用間隔:
	物品使用后, 需要間隔多久才能再次使用.
	
优先級:
	优先級較高的物品滿足條件會优先使用.

使用條件:
	具体條件請參照 bot_adduseskill 指令

---------------------------------------

*bot_addevent <"事件名稱">{,<触發延遲>{,<优先級>{,<触發條件>{,<參數1>{,<參數2>{,<角色ID>}}}}}};

	机器人触發事件, 在滿足條件時, 机器人會自動使用物品.

触發間隔:
	間隔多久檢測一次事件滿足條件, 默認 1000 毫秒.

优先級:
	优先級較高的事件滿足條件會优先触發.

触發條件:
	具体條件請參照 bot_adduseskill 指令

---------------------------------------

*bot_addlootitem <物品ID>{,<拾取別人的戰利品>{,<角色ID>}};

	添加物品到拾取列表, 當打怪完成后會拾取附近的道具, 默認拾取別人的戰利品

---------------------------------------

*bot_addattackmob <魔物ID>{,<优先級>{,<角色ID>}};

	添加魔物到攻擊列表, 當選擇魔物時, 优先選擇优先度高的魔物
	當魔物列表中有魔物時, 則不會攻擊攻擊列表中沒有的魔物

---------------------------------------

*bot_addmode <模式>{,<參數>{,<角色ID>}};

	添加机器人的模式

模式:
	BOT_IDEA             - 閑置狀態, 可通過 bot_run 移除此狀態.
	BOT_SKILL_ATK        - 使用技能攻擊
	BOT_WEAPON_ATK       - 使用普通攻擊
	BOT_SUPPORT_SELF     - 使用技能輔助自己
	BOT_SUPPORT_FRIEND   - 使用技能輔助隊友
	BOT_NO_WALK          - 不自動尋路 (遇敵依然會走過去攻擊)
	BOT_FOLLOW_WALK      - 跟隨指定的AID (參數為被跟隨玩家的AID)
	BOT_RANDOM_WALK      - 范圍內沒有敵人時, 使用隨机尋路尋找敵人
	BOT_ASTAR_WALK       - 范圍內沒有敵人時, 使用A*路尋找敵人 (优先級大于 BOT_RANDOM_WALK)
	BOT_IGNORE_TOUCH     - 無視傳送點和NPC触發對話
	BOT_IGNORE_SAME_ELE  - 無視同屬性的敵人 (參數為修正值, 參數為50時, 屬性修正低于50的魔物不打)
	BOT_ALWAYS_MASTER    - 只攻擊敵人的主人
	BOT_COUNTERATTACK    - 對正在攻擊机器人的實体進行反擊
	BOT_OFFLINE          - 采用离線挂机模式

---------------------------------------

*bot_delmode <模式>{,<角色ID>};

	移除机器人的模式

模式: 
	請查看 bot_addmode 指令

---------------------------------------

*bot_hasmode <模式>{,<角色ID>};

	判斷机器人是否有相關的模式, 判斷多個模式可以相加

模式: 
	請查看 bot_addmode 指令

---------------------------------------

*bot_setdelay <類型>,<最小延遲>,<最大延遲>{,<角色ID>};

	為机器人動作增加隨机延遲, 可以看起來更像是玩家

類型:
	BOT_DELAY_LOOT		拾取物品延遲(默認: 300ms ~ 800ms)
	BOT_DELAY_CHOOSE	選擇敵人延遲(默認: 800ms ~ 1300ms)
	BOT_DELAY_SKILL		使用技能延遲(默認: 0ms ~ 300ms, 如果想秒 7 請去掉隨机延遲)

---------------------------------------

*bot_trade <類型>;
*bot_trade <類型>,<背包序號>,<交易數量>;
*bot_trade <類型>,<ZENY數量>;

	當BOT收到交易請求時, 可以通過這個指令操作BOT交易

類型:
	BOT_ACT_ACCEPT  同意交易并進入交易窗口
	BOT_ACT_REFUSE  拒絕交易
	BOT_ACT_ADDITEM 在交易窗口中添加道具(必須在交易窗口下使用, 否則無效果)
	BOT_ACT_ZENY    在交易窗口中添加ZENY(必須在交易窗口下使用, 否則無效果)
	BOT_ACT_OK      确認交易
	
注意: 該指令需要配合 OnBOTRecvActEvent 腳本事件一起使用

---------------------------------------

*bot_party <類型>;

	當BOT收到加入隊伍請求時, 可以通過這個指令操作BOT接受或拒絕申請

類型:
	BOT_ACT_ACCEPT  同意加入
	BOT_ACT_REFUSE  拒絕加入
	
注意: 該指令需要配合 OnBOTRecvActEvent 腳本事件一起使用

---------------------------------------

*bot_guild <類型>;

	當BOT收到加入公會請求時, 可以通過這個指令操作BOT接受或拒絕申請
	
類型:
	BOT_ACT_ACCEPT  同意加入
	BOT_ACT_REFUSE  拒絕加入
		
注意: 該指令需要配合 OnBOTRecvActEvent 腳本事件一起使用

---------------------------------------

*bot_reset {<類型>{,<角色ID>}};

	重置机器人相關信息, 多個重置將類型相加即可

類型: 
	BOT_REST_SKILL  - 重置技能列表
	BOT_REST_ITEM   - 重置物品列表
	BOT_REST_EVENT  - 重置事件列表
	BOT_REST_LOOT   - 重置拾取列表
	BOT_REST_MOB    - 重置魔物列表
	BOT_REST_MODE   - 重置机器人模式, 并將机器人設置為閑置(BOT_IDEA)狀態
	BOT_REST_ALL    - 重置以上所有
	  
---------------------------------------

*is_bot {<角色ID>};

	用于判斷玩家是否是机器人
	
注意:當對玩家使用除bot_stop以外的指令時, 玩家則會被判定為机器人

返回: 0 時玩家不是BOT, 1 時BOT為閑置(BOT_IDEA)狀態, 2 時BOT為運行狀態

---------------------------------------

*bot_run {<運行時長>{,<角色ID>}}};

	啟動机器人, 用于移除机器人的閑置(BOT_IDEA)狀態, 效果等同于 bot_delmode(BOT_IDEA).

返回: -1 沒有机器人的相關配置
      -2 角色已死亡
	  -3 角色處于挂店或開啟倉庫的狀態

例子: 請查看 npc\BetterRa\BetterRa_bot.txt

---------------------------------------

*bot_pause {<角色ID>};

	暫停机器人, 用于為机器人添加閑置(BOT_IDEA)狀態, 效果等同于 bot_addmode(BOT_IDEA).

---------------------------------------

*bot_stop {<是否登出>{,<角色ID>}};

	釋放一個机器人
	
是否登出:
	1 - 登出
	0 - 保持在線, 如果BOT為离線挂机則無效果
	
---------------------------------------

*openchat "<標題>"{,<人數上限>{,"<密碼>"{,<角色ID>}}};

開啟一個聊天窗口

---------------------------------------

*openvending "<商店名稱>"{,<物品ID>,<物品數量>,<物品售价>{,<物品ID>,<物品數量>,<物品售价>...{,<角色ID>}}};

開啟一個販賣商店, 手推車中必須有這些物品.

---------------------------------------

*openbuying "<商店名稱>"{,<物品ID>,<物品數量>,<物品售价>{,<物品ID>,<物品數量>,<物品售价>...{,<角色ID>}}}

開啟一個采購商店, 最多只能同時采購 3 個物品.

---------------------------------------

*http_get "<URL>",<超時時間(秒)>,<獲取后是否當做NPC文件加載>{,<保存數字>};

發送GET指令. 通過 OnHTTPReceivedEvent 事件返回GET內容, 注意本指令不支持HTTPS鏈接..

<獲取后是否當做NPC文件加載> 0為否, 1為是, 加載的腳本可以為网絡上的加密腳本
<保存數字> 可以保存玩家的CID或者AID 可以在 OnHTTPReceivedEvent 事件后 $@http_num 變量返回, 用于綁定角色

注意!!加載腳本設置為是的時候 將不會触發事件, 直接會被加載...

OnHTTPReceivedEvent 事件返回變量:
	
	$@http_code           HTTP 返回代碼（200 404 301 302 502等）
	$@http_name$          HTTP header 返回名(數組),
	$@http_val$           HTTP header 值(數組),
	$@http_header_count   HTTP header 數組長度.

	$@http_url$     為 http_get腳本指令中的 <URL>
	$@http_host$    為 http_get腳本指令中的 <网址>
	$@http_folder$  為 http_get腳本指令中的 <网址剩余部分>
	$@http_num      為 http_get腳本指令中的 <保存數字>
	$@http_str$     為返回的內容
	
授權例子: 
	http_get("http://www.example.com/login.php?account=name&passworld=123456",3,0); 登陸后端獲取的IP地址并落地并返回yes

	OnHTTPReceivedEvent:
		
		//判定网址和登陸頁面, 并判斷返回內容是否為yes(為yes則為登陸成功)..
		if($@http_host$ == "www.example.com" && compare($@http_folder$,"login.php") && $@http_str$ == "yes"){
			
			//在后端用登陸時的IP決定是否返回NPC腳本
			http_get("http://www.example.com/script.php?npc=test0.txt",3,1);
			http_get("http://www.example.com/script.php?npc=test1.txt",3,1);
			http_get("http://www.example.com/script.php?npc=test2.txt",3,1);
			http_get("http://www.example.com/script.php?npc=test3.txt",3,1);
		}
	
---------------------------------------

*callshop "<商店名字>",<配置>,"<過濾文本>";

配置為10時, 為打開向NPC出售的販賣菜單, 菜單可以使用過濾文本.
過濾為本: "type:物品類型{,物品類型}..;item:物品ID{,物品ID}..;"
例: callshop "shoptest",10, "type:6;item:501,502;" 彈出販賣菜單, 菜單只顯示卡片\紅色藥水\赤色藥水, 如果玩家身上有相應物品時才會被顯示...

---------------------------------------

*unit_Astar_walkto <GID>,<x坐標>,<y坐標>{,<自動釋放>{,<尋路AI>,{<參數>,{<"事件名稱">}}}};

全圖尋路，玩家、魔物或NPC可行走至地圖上的任意一點。
<自動釋放> 默認為1，如果需要被多次調用可以將自動釋放設置為 0， 將會一直存在路點系統中。

尋路AI:
	PH_WALKBACK: 离開路徑<參數>格或遇到障礙時, 不再追蹤, 自動行走返回路徑. (默認)
	PH_WARPBACK: 离開路徑直到失去目標后, 傳送回路徑繼續走完路徑.
	PH_IGNOREWALK: 永遠不追蹤目標, 但如果目標在攻擊(拾取)范圍內, 依然會攻擊(拾取).
	PH_IGNOREALL: 永遠不做任何其他事情, 一路走到路點結束.
	PH_ASTARTWALK: 离開路徑后, 調用A*算法計算路徑, 并走到最終規定的路點終點).
	PH_ASTARTWALKBACK: 离開路徑后, 調用A*算法計算返回路徑.

<參數> 默認為 25, 為 PH_WALKBACK 提供返回距离， 當魔物离開路徑 <參數> 格時，魔物不在追蹤返回路徑。
<"事件名稱"> 為路徑點走完以后調用的事件，魔物路徑尋路失敗也會執行此命令。可通過$@gid獲得触發事件魔物的GID

---------------------------------------

*unit_cross_map_walkto <GID>,"<地圖名>",<x坐標>,<y坐標>{,<尋路AI>,{<參數>,{<"事件名稱">}}};

穿越地圖的全圖尋路，玩家、魔物或NPC可通過傳送點走至指定地圖上的任意一點。
<自動釋放> 默認為1，如果需要被多次調用可以將自動釋放設置為 0， 將會一直存在路點系統中。

尋路AI:
	PH_WALKBACK: 离開路徑<參數>格或遇到障礙時, 不再追蹤, 自動行走返回路徑. (默認)
	PH_WARPBACK: 离開路徑直到失去目標后, 傳送回路徑繼續走完路徑.
	PH_IGNOREWALK: 永遠不追蹤目標, 但如果目標在攻擊(拾取)范圍內, 依然會攻擊(拾取).
	PH_IGNOREALL: 永遠不做任何其他事情, 一路走到路點結束.
	PH_ASTARTWALK: 离開路徑后, 調用A*算法計算路徑, 并走到最終規定的路點終點.
	PH_ASTARTWALKBACK: 离開路徑后, 調用A*算法計算返回路徑.

<參數> 默認為 25, 為 PH_WALKBACK 提供返回距离， 當魔物离開路徑 <參數> 格時，魔物不在追蹤返回路徑。
<"事件名稱"> 為路徑點走完以后調用的事件，魔物路徑尋路失敗也會執行此命令。可通過$@gid獲得触發事件魔物的GID

---------------------------------------

*mobstaypos <GID>,<x坐標>,<y坐標>{,<追蹤距离>};

將魔物固定于一點，被固定的魔物只能在坐標點周圍活動。
<追蹤距离> 當目標大于追蹤距离時則返回。

---------------------------------------

*instance_name {<副本ID>};

獲取玩家所擁有的副本的名字。副本ID 通過 instance_id 指令獲取。

---------------------------------------

*magicshield <种族>,<護盾血量>,<持續時間>;

在持續時間內，抵擋相應种族的傷害。

參數<种族>: 
	RC_Angel		天使系
	RC_Brute		動物系
	RC_DemiHuman	人形系
	RC_Demon		惡魔系
	RC_Dragon		龍系
	RC_Fish			魚貝系
	RC_Formless		無形系
	RC_Insect		昆虫系
	RC_Plant		植物系
	RC_Player		玩家
	RC_Undead		不死系
	RC_All			所有种族
	
---------------------------------------

*getbonus <類型>,<參數或變量>{,<參數或變量>{,<參數或變量>{,<參數或變量>{,<參數或變量>}}}};
*getcharbonus <類型>,<參數或變量>,<角色ID>;
*getcharbonus <類型>,<參數或變量>,<參數或變量>,<角色ID>;
*getcharbonus <類型>,<參數或變量>,<參數或變量>,<參數或變量>,<角色ID>;
*getcharbonus <類型>,<參數或變量>,<參數或變量>,<參數或變量>,<參數或變量>,<角色ID>;
*getcharbonus <類型>,<參數或變量>,<參數或變量>,<參數或變量>,<參數或變量>,<參數或變量>,<角色ID>;

用來獲取 bonus 的參數，當參數填寫變量時則獲取相應位置上的參數。

注: 
	getcharbonus 用法与getbonus相同, 只是最后一個參數為玩家的角色ID, 用來獲取指定玩家的 bonus 參數
	當 bf 參數為 -1 時 則忽略 bf參數, 獲取的結果為所有滿足條件之和
	
例﹕

	getbonus bAddEle,Ele_Dark,.@val;
	dispbottom "你對屬性 Ele_Dark 增加 "+.@val+" 的傷害";
	getbonus bAddEle,Ele_Dark,.@val,BF_SHORT;	
	dispbottom "近距离物理攻擊時, 你對屬性 Ele_Dark 增加 "+.@val+" 的傷害";
	
	
支持的 Bonus 列表:
	bonus2 bAddEle,e,x;
	bonus3 bAddEle,e,x,bf;
	bonus2 bMagicAddEle,e,x;
	bonus2 bSubEle,e,x;
	bonus3 bSubEle,e,x,bf;
	bonus2 bSubDefEle,e,x;
	
	bonus2 bAddRace,r,x;
	bonus2 bMagicAddRace,r,x;
	bonus2 bSubRace,r,x;
	
	bonus2 bAddClass,c,x;
	bonus2 bMagicAddClass,c,x;
	bonus2 bSubClass,c,x;
	
	bonus2 bAddSize,s,x;
	bonus2 bMagicAddSize,s,x;
	bonus2 bSubSize,s,x;
	
	bonus2 bAddDamageClass,mid,x;
	bonus2 bAddMagicDamageClass,mid,x;
	bonus2 bAddDefMonster,mid,x;
	bonus2 bAddMDefMonster,mid,x;
	
	bonus2 bAddRace2,mr,x;
	bonus2 bSubRace2,mr,x;
	bonus2 bMagicAddRace2,mr,x;
	
	bonus2 bSubSkill,sk,n;
	
	bonus2 bResEff,eff,n;
	
	bonus bCastrate,n;
	bonus2 bCastrate,sk,n;
	bonus bFixedCastrate,n;
	bonus2 bFixedCastrate,sk,n;
	bonus bDelayrate,n;
	bonus2 bSkillCooldown,sk,t;
	
---------------------------------------

*bonus_minfix <類型>,<參數或變量>{,<參數或變量>{,<參數或變量>{,<參數或變量>{,<參數或變量>}}}},<最小值>;
*bonus_maxfix <類型>,<參數或變量>{,<參數或變量>{,<參數或變量>{,<參數或變量>{,<參數或變量>}}}},<最大值>;

此指令可用在 OnPCStatCalcEvent 事件下面用來修正相應的bonus數值。

例:
	bonus_maxfix bAddEle,Ele_Dark,.@val,BF_SHORT,80; // 近距离攻擊時的暗屬性修正不能大于80%, .@val 獲取最終的值
	bonus_minfix bAddEle,Ele_Dark,.@val,10; // 暗屬性修正不能小于10%, .@val 獲取最終的值
	
支持的 Bonus 列表同getbonus.

---------------------------------------

*bonus_ratefix <類型>,<最大值>{,<角色ID>};

此指令可用在 OnPCStatCalcEvent 事件下面用來修正相應的bonus數值。

例﹕
	bonus_ratefix bAddEle,50; // bAddEle屬性修正不能大于50%
	
支持的 Bonus 列表同getbonus.
	
---------------------------------------

*getrateidx <概率數組>;
*getrateidx <概率>{,<概率>{,<概率>....}};

根据提供的概率返回該概率值在數組中的位置，被概率值越大選中的概率越大。

例﹕
	setarray .@item[0],501,502,503;
	setarray .@rate[0],1000,20,10;
	getitem .@item[getrateidx(.@rate)],1;
	
	// 有 1000/(1000+20+10) 的概率獲得紅色藥水(501)
	// 有 20/(1000+20+10) 的概率獲得赤色藥水(502)
	// 有 10/(1000+20+10) 的概率獲得黃色藥水(503)
	
---------------------------------------

*readstatus <參數>;

獲取屬性的總量。

參數: 
    bStr:  獲取玩家所擁有的 STR 總數值
	bAgi:  獲取玩家所擁有的 AGI 總數值
	bVit:  獲取玩家所擁有的 VIT 總數值
	bInt:  獲取玩家所擁有的 INT 總數值
	bDex:  獲取玩家所擁有的 DEX 總數值
	bLuk:  獲取玩家所擁有的 LUK 總數值
	
---------------------------------------

*getareamember <團隊類型>,{<范圍>{,<角色ID>}};

獲取指定玩家范圍內同組隊、公會、戰場成員數量及AID

類型﹕
	PARTY_AREA:  范圍內的隊伍成員
	GUILD_AREA:  范圍內的公會成員
	BG_AREA:     范圍內的戰場成員

返回值:
	成員數數量

返回變量:
	@member_aid 儲存成員AID

---------------------------------------

*getmapmember <團隊類型>,"<地圖名>",<團隊ID>;

獲取地圖內指定組隊、公會、戰場成員數量及AID

類型﹕
	PARTY_AREA:  范圍內的隊伍成員
	GUILD_AREA:  范圍內的公會成員
	BG_AREA:     范圍內的戰場成員

返回值:
	成員數數量

返回變量:
	$@member_aid 儲存成員AID
	
---------------------------------------

*addatkevent <攻擊類型>,<概率>,<次數>,"<事件>",<触發時間間隔>{,<角色ID>};

添加攻擊事件, 達到攻擊触發的事件條件后, 事件將會自動触發..

攻擊類型:
按攻擊范圍:
	BF_SHORT:  近距离攻擊
	BF_LONG:   遠距离攻擊
	默認:   BF_SHORT+BF_LONG
按攻擊類型:
	BF_WEAPON: 物理攻擊
	BF_MAGIC:  魔法攻擊
	BF_MISC:   混合攻擊
	默認:   BF_WEAPON
按技能類型:
	BF_NORMAL: 普通攻擊
	BF_SKILL:  技能攻擊
	默認:   如果攻擊類型是 BF_WEAPON (only) BF_NORMAL, 否則 BF_SKILL+BF_NORMAL.

概率: 為千分率, 触發事件的概率
次數: 攻擊打到次數后触發事件
触發時間間隔: 每次触發時間后隔多少毫秒以后才可以触發下一次

注意!! 如果概率和次數同時被填寫, 那么兩個條件必須都滿足才會触發...
事件: 被触發的事件名, 格式為"NPCNAME::EVENTNAME"..

注意!!!!!!!!如果概率和次數都填寫0的話, 每次攻擊都會触發事件, 這兩個參數請根据情況填寫, 如果事件触發太頻繁, 可能會因為事件下的代碼調用過于頻繁造成服務器CPU資源被大量占用的情況..

---------------------------------------

*delatkevent <攻擊類型>{,<角色ID>};

刪除按攻擊類型触發的事件的條件.

---------------------------------------


*getatkevent <攻擊類型>,<標簽>{,<角色ID>};

獲得按攻擊類型触發的事件的條件.

<標簽>:
	為 1 時, 返回 攻擊過多少次, 當達到最高次時清零, 并触發事件.
	為 2 時, 返回 addatkevent指令中第2個參數(<概率>)
	為 3 時, 返回 addatkevent指令中第3個參數(<次數>)
	為 4 時, 返回 addatkevent指令中第4個參數("<事件>")
	為 5 時, 返回 addatkevent指令中第5個參數(<触發時間間隔>)

---------------------------------------

*gettarget{<GID>};

獲取正在攻擊目標的GID..

---------------------------------------

*unitskillfixed <GID>,<技能ID>,<念咒修正>,<傷害修正>,<修正類型>{,<持續時間>};

持續時間內, 對技能的念咒時間, 傷害進行修正, 如果設置修正類型為 0, 則直接增加修正的相應數量. 

技能ID:
	如果技能ID為-1, 對所有技能攻擊進行修正
	如果技能ID為-2, 對所有普通攻擊進行修正
	如果技能ID為-3, 對所有普通攻擊和技能攻擊進行修正

修正類型(掩碼計算:選擇多項掩碼相加):
	&0: 念咒和傷害在原有基礎上累加(优先級小于下列所有)
	&1: 念咒直接修正(<念咒修正>提供的數据就是念咒總時長, 优先級大于 &4)
	&2: 傷害直接修正(<傷害修正>提供的數据就是技能總傷害, 优先級大于 &8)
	&4: 念咒根据百分比修正(<念咒修正>提供修正的百分比)
	&8: 傷害修正根据百分比修正(<傷害修正>提供修正的百分比)

例:
	unitskillfixed 19,1000,5000000,3; //將下一次火箭術技能的念咒修改為1秒, 傷害修改為 5000000
	unitskillfixed 19,1000,5000000,0; //將下一次火箭術技能的念咒累加1秒, 傷害累加 5000000
	unitskillfixed 19,1000,5000000,2; //將下一次火箭術技能的念咒累加1秒, 傷害修改為 5000000

---------------------------------------

*unitskillfixedreset <GID>;

將之前的修正清零.

---------------------------------------

*gettarget {<GID>};

獲取正在攻擊目標的GID。

---------------------------------------

*homattack <攻擊類型>;

開啟關閉生命体自動攻擊, 因為在2017年的一次更新中禁用了生命体自動攻擊, 所以添加此指令.

<攻擊類型> 0: 關閉
           1: 只會普通攻擊
           2﹕普通攻擊和單体技能
           3﹕普通攻擊和群体技能
		   
---------------------------------------

*mobdrop <GID>,<魔物ID>{,<掉落倍率>{,<最大掉落概率>}}

模擬魔物掉落, 該魔物數据庫中的掉落物品會依次計算掉落（多個物品可以同時掉落）, 
掉落位置為<GID>所在的位置，如果<GID>為 0 則物品直接給予腳本相關聯的玩家，對于玩家來說AID既是GID。
掉落概率 = 魔物數据庫中物品的掉落概率 x <掉落倍率> / 100
<最大掉落概率>用來約束最終掉落概率

---------------------------------------

*sortarray <數組>{,<標簽>};
*sortarray <參考數組>,<排序數組>,<標簽>;

對數組進行排序。

<標簽>(掩碼選項)
	&1 : 正序排列
	&2 : 倒序排列
	&4 : 根据<參考數組>的值對<排序數組>的值進行排序
	&8 : 根据<參考數組>的值對<參考數組>的鍵進行排序, 此時<參考數組>正常進行排序, <排序數組>為對鍵重排的結果的存儲數組

說明﹕
	鍵為中括號里面的數字值為變量中保存的數字，.@example[鍵] = 值;
	排序鍵值不受限制
	
例1﹕
	.@example[100005] = 1;
	.@example[982254] = 2;
	.@example[852742] = 3;
	.@example[758787] = 4;
	
	sortarray(.@example, .@result, 1 | 8);  //根据.@example值的順序對.@exampl的鍵進行正序排序
	// .@example 為 1,2,3,4
	// .@result 為 100005,982254,852742,758787
	
	sortarray(.@example, 2); //對值進行反序排序
	// .@example 為 4,3,2,1
例2﹕
	setarray .@example[10],10,1,3,8,9,5,7,2,4,6,0;
	
	sortarray(.@example); //對值進行正序排序
	// .@example 為 0,1,2,3,4,5,6,7,8,9,10
	sortarray(.@example, 2); //對值進行反序排序
	// .@example 為 10,9,8,7,6,5,4,3,2,1,0
例3﹕
	setarray .@example[0],5,1,4,2,3;
	setarray .@result[0],10,20,30,40,50;
	
	sortarray(.@example, .@result, 2 | 4); //根据.@example值的順序對.@result的值進行反序排序
	// .@example 為 5,4,3,2,1 
	// .@result 為 10,30,50,40,20
	
	sortarray(.@example, .@result, 1 | 4); //根据.@example值的順序對.@result的值進行正序排序
	// .@example 為 1,2,3,4,5
	// .@result 為 20,40,50,30,10
	
例4﹕
	setarray .@example[0],5,1,4,2,3;
	setarray .@result[0],0,0,0,0,0;
	
	sortarray(.@example, .@result, 2 | 8); //根据.@example值的順序對.@exampl的鍵進行反序排序
	// .@example 為 5,4,3,2,1
	// .@result 為 0,2,4,3,1

---------------------------------------

*npcshopattach "<name>"{,<flag>};

拓展 OnSellItem 事件添加返回 @sold_idx 數組，返回物品在背包中的序列。

---------------------------------------

*getdaytick("<標准時間格式>");
*getdaytick(<年>,<月>,<日>{,<時>{,<分>{,<秒>}}});

根据所提供的時間返回時間戳。從1970年1月1日至提供時間。
標准時間格式為 "年-月-日 時:分:秒" 或 "年-月-日"

返回值:
	返回時間戳, 時間戳為數字
	
例:
	getdaytick("2018-12-31");
	getdaytick(2018,12,31);
	getdaytick("2018-12-31 5:23:31");

---------------------------------------

*unitmasterid(<gid>);

獲得GID對應的主人的GID, 支持寵物、魔物、生命体、佣兵、元素精靈、技能

返回值:
	主人的GID，如果沒有找到主人的話則返回0

---------------------------------------

*is_attach({<角色ID>});

獲取玩家是否跟腳本有關聯, 一般用來判斷玩家是否正在跟NPC對話
一般用在腳本外使用, 如果在腳本外獲取 GID 則使用 getattachnpc 指令

例:
501,Vip_list,VIP菜單,11,10,,70,,,,,0xFFFFFFFF,63,2,,,,,,{ if (is_attach()) dispbottom "使用VIP菜單請先關閉与 "+getunitname(is_attach())+" 的交談"; },{},{}

prontera,153,179,5	script	is_attach測試	56,{
	mes "正在与NPC對話,請不要點擊關閉,并嘗試使用VIP菜單";
	close;
}

返回值:
	正在對話則返回上層關聯 NPC 的 GID , 沒有在對話返回0;

---------------------------------------

*getattachnpc({<角色ID>});

獲得玩家當前激活的 NPC 的 GID.

prontera,153,179,5	script	getattachnpc測試	56,{
	mes "正在与NPC對話, NPC 名稱: "+getunitname(getattachnpc());
	close;
}

返回值:
	NPC 的 GID , 沒有在對話返回0;
	
---------------------------------------

*unitskilluse <GID>,<技能ID>,<技能等級>{,<目標GID>,<吟唱時間>{,<是否可打斷>}};
*unitskilluse <GID>,"<技能名稱>",<技能等級>{,<目標GID>,<吟唱時間>{,<是否可打斷>}};

對目標使用技能, 效果類似于unitskilluseid, 但指令會自動判斷地面技能還是目標技能, 當使用技能為地面技能時將會以目標為中心釋放技能。
當是否打斷被省略時，技能會根据 skill_db.txt 中的 castcancel 來判斷是否可打斷。

---------------------------------------

* mobskill <魔物GID>,<技能ID>,<技能等級>,<詠唱時間(秒)>,<是否可打斷>,<目標類型>{,<偏移x>,<偏移y>};
* mobskill <魔物GID>,<"技能名稱">,<技能等級>,<詠唱時間(秒)>,<是否可打斷>,<目標類型>{,<偏移x>,<偏移y>};

魔物使用技能, 如果怪物正在詠唱則取消目前釋放的技能, 此指令對寫腳本的人非常友好.
作者kuku

<是否可打斷>
   0: 不可打斷
   1: 可以打斷

<目標類型>
   0: 自己
   1: 怪物當前目標
   2: 怪物的主人
   3: 隨机目標
   
<偏移x> 地面技能相對于目標坐標x軸的偏移量
<偏移y> 地面技能相對于目標坐標y軸的偏移量

---------------------------------------

*sleep3 <時間>

延時函數, 不會丟失与玩家的關聯, 但是玩家与腳本沒有關聯也不會報錯.

---------------------------------------

*unitgettarget(<GID>);
*gettarget(<GID>);

獲取GID對象正在攻擊的目標的GID.

---------------------------------------

*when_progressbar_abort_doevent;
*when_progressbar_abort_doevent(<角色ID>);

使用此腳本后 progressbar 被打斷后的事件 OnPCProgressAbortEvent 才會被触發.

---------------------------------------

*isequippedcnt2(<物品ID>{,<物品ID>{,<物品ID>{,<物品ID>}}});

用法同 isequippedcnt 可以支持任何物品ID, 主要用于拓展附魔道具. 

返回值:
	返回數量

---------------------------------------

*isequipped2(<物品ID>{,<物品ID>{,<物品ID>{,<物品ID>}}})

用法同 isequipped 可以支持任何物品ID, 主要用于拓展附魔道具. 

返回值:
	返回數量

---------------------------------------

*instance_enter_left {<角色編號>};

返回上次离開副本的位置..必須在 BatterRA.conf 中配置 instance_leave_record 才能生效
該函數通過解析 instance_record$ 得到副本信息, 可自行判斷變量中數据的合法性
不是同一個副本不會被傳入, 可用于掉線重進進入副本, 也可用于离開副本后重回副本

返回值﹕
	參考 instance_enter

---------------------------------------

*instance_record {<標簽>{,<角色ID>}};

可用來檢查變量 instance_record$ 保存的數据是現在玩家正在進行的副本
可用于獲取變量 instance_record$ 中保存的地圖、X坐標、Y坐標

<標簽>
	留空 ﹕檢查 instance_record$ 保存的數据是現在玩家正在進行的副本, 合法返回1, 否則返回0
	1 : 返回副本的原地圖 可通過 instance_map函數獲取副本地圖, 失敗返回0
	2 ﹕返回X坐標, 失敗返回0
	3 ﹕返回Y坐標, 失敗返回0

---------------------------------------

*getmobdmglog(<魔物GID>,<CID變量>,<傷害變量>{,<最大獲取數量>{,<根据傷害降序排序>})};

用來獲取對魔物造成傷害排名數据, 數据存入<存儲變量>, 玩家下線, 死亡后重新開始則該玩家的相應數据會被清空。
此指令最多只能獲得30個傷害數据。

<CID變量>
	用于存儲玩家CID
	
<傷害變量>
	用于存儲傷害數值
	
<根据傷害降序排序>
	0 : 否 (根据玩家傷害順序排序)
	1 : 是 (默認自動排序)

返回值:
	返回<存儲變量>中數据的個數。

---------------------------------------

*charid2rid(角色ID);

返回角色ID(charid)對應的賬號ID(rid, gid, aid)

返回值:
	返回AID

---------------------------------------

*unithide <GID>,<角色ID>{,<特效編號>};

臨時隱藏某個GID，隱藏只針對<角色ID>，當玩家离開再回來時還可以看到這個目標。
可通過NPC事件 OnDisplay 配合長期對某個玩家隱藏/顯示指定NPC，OnDisplay使用方法參見 npc\BetterRa\BetterRa_event_demo.txt

特效編號:  
	0: 沒有特效
	1: 登出特效
	2: 瞬移特效(默認)
	3: 死亡特效

---------------------------------------

*unitshow <GID>,<角色ID>;

臨時顯示某個GID，顯示只針對<角色ID>，當玩家离開再回來時還是看不到這個目標。
可通過NPC事件 OnDisplay 配合長期對某個玩家隱藏/顯示指定NPC，OnDisplay使用方法參見 npc\BetterRa\BetterRa_event_demo.txt

---------------------------------------

*preg_match(<匹配正則>,<匹配文本>{,<索引位置>});

此指令為官方指令，BetterRA支持取出匹配子項，匹配文本被保存在 $@p$[0] 中。
子項被保存在$@p$[1]、$@p$[2]、$@p$[3]、$@p$[4].....中

返回值﹕
	匹配數量(即$@p$數組成員數)

---------------------------------------

*showvending("<NPC名稱>",<是否顯示>{,"<招牌名稱>"});

使指定<NPC名稱>頭上顯示露天商店的招牌, 點擊招牌可触發NPC

是否顯示:
	0 - 隱藏招牌
	1 - 顯示招牌
	
別名: showvend

用法:
prontera,150,150,4	shop	Vend_Title_Test	48,501:-1

-	script	NPC_Vend	-1,{
	end;
	OnInit:
		showvending("Vend_Title_Test", 1, "有招牌的商店");
	end;
}

返回值:
	操作成功則返回 1, 失敗則返回 0

---------------------------------------

*showbuying("<NPC名稱>",<是否顯示>{,"<招牌名稱>"});

使指定<NPC名稱>頭上顯示采購商店的招牌, 點擊招牌可触發NPC

是否顯示:
	0 - 隱藏招牌
	1 - 顯示招牌

用法:
prontera,150,150,4	shop	Buy_Title_Test	48,501:-1

-	script	NPC_BUY	-1,{
	end;
	OnInit:
		showbuying("Buy_Title_Test", 1, "有招牌的商店");
	end;
}

返回值:
	操作成功則返回 1, 失敗則返回 0

---------------------------------------

*killaroundmonster <GID>,<范圍>,<魔物mode>;

殺死GID范圍內的魔物, 帶有<魔物mode>的魔物不會被炸死

<魔物mode>參數可以多選, 用|連接

注意﹕指令對無敵的魔物(UMOB_DMGIMMUNE)、華麗水晶和守護石無效

列﹕
    killaroundmonster getcharid(3),10,MD_MVP; //殺死除了MVP之外的10格范圍內的魔物
	
---------------------------------------

*isloggedin2 <角色ID>;

獲取玩家是否在線, 在線則返回賬號ID (account id) 不在線則返回 0

---------------------------------------

*unitatkeventmark <GID>,<標記值>;

指令為 OnPCAttackFilter 事件的標記指令, 用于標記玩家、魔物、寵物、生命体、佣兵等。
當被標記的魔物被攻擊時會強制触發 OnPCAttackFilter 事件, 無視 BetterRA.conf 中 attack_event 配置,
事件中返回的 dmg_mark 為此處設定的 <標記值>

---------------------------------------

*unitatkedeventmark <GID>,<標記值>;

指令為 OnPCAttackedFilter 事件的標記指令, 用于標記玩家、魔物、寵物、生命体、佣兵等。
當被標記的魔物被攻擊時會強制触發 OnPCAttackedFilter 事件, 無視 BetterRA.conf 中 attacked_event 配置,
事件中返回的 dmg_mark 為此處設定的 <標記值>

---------------------------------------

*setcell "<地圖名稱>",<x1>,<y1>,<x2>,<y2>,<類型>,<開關>;

加入新類型 CELL_SAFEZONE 設置安全區, 安全區外的玩家或魔物不可以以安全區內的玩家為目標(包括GVG, PVP地圖)

---------------------------------------

*checkcell ("<地圖名稱>",<x坐標>,<y坐標>,<類型>);

加入新類型 CELL_CHKSAFEZONE 安全區檢查

---------------------------------------

*setquesttime <任務ID>,<時間(秒)>{,<角色ID>};

設置任務到期時間, 如果玩家沒有任務時, 賦予任務并設置到期時間, 到期時間無視 quest_db.txt 中的第二項
當玩家有該任務時, 則只設置任務到期時間

---------------------------------------

*runitemscript <物品ID>,{<類型>{,<角色ID>}};

運行物品的腳本..

<類型>:
 0 - Script
 1 - OnEquip_Script
 2 - OnUnequip_Script

成功返回1, 失敗返回0

---------------------------------------

*pcisdead {<GID>};

檢查玩家是否死亡, 死亡返回 1, 未死亡或者不在線時返回 0 

---------------------------------------

*unitdamage <GID>,<傷害值>{,<打擊次數>};
*unitdamagerate <GID>,<傷害扣除MAXHP比例>{,<打擊次數>};

使目標受到傷害值, 可以顯示傷害數字, 當受到傷害為玩家時, 多次打擊沒有黃色傷害值.

---------------------------------------

*unitsleep <GID>,<時間毫秒>;

延遲一定時間, 指令与GID綁定, 當GID在延遲過程中不存在時返回 0

---------------------------------------

*unitsleepend <GID>,<時間毫秒>;

延遲一定時間, 指令与GID綁定, 當GID在延遲過程中不存在時腳本停止

---------------------------------------

*unitspecialeffect <GID>,<特效ID>{,<發送目標>{{,<目標GID>}});

使指定實体<GID>顯示一個特效效果, 類似于 specialeffect 不過他可以顯示給任何目標

發送目標
   AREA - 發送給可視范圍內的玩家(默認)
   SELF - 發送給自己, 如果指定<目標GID> 則特效只能指定玩家看到
   PARTY_AREA - 發送給可視范圍內的指定隊伍
   GUILD_AREA - 發送給可視范圍內的指定公會
   BG_AREA - 發送給可視范圍內的指定BG隊伍
   
---------------------------------------

*specialeffectnum(<特效ID>,<特效參數>{,<發送目標>{,<源GID>{,<目標GID>}}});
*specialeffectnum(<特效ID>,<特效參數>{,<發送目標>{,"<源NPC名>"{,<目標GID>}}});

使目標顯示一個帶參數的特效效果, 如果指定 <源GID>("<源NPC名>") 則特效會顯示在指定的源實体上

發送目標
   AREA - 發送給可視范圍內的玩家(默認)
   SELF - 發送給自己, 如果指定<目標GID> 則特效只能指定玩家看到
   PARTY_AREA - 發送給可視范圍內的指定隊伍
   GUILD_AREA - 發送給可視范圍內的指定公會
   BG_AREA - 發送給可視范圍內的指定BG隊伍

---------------------------------------

*removespecialeffect(<特效ID>{,<發送目標>{,<源GID>{,<目標GID>}}});
*removespecialeffect(<特效ID>{,<發送目標>{,"<源NPC名>"{,<目標GID>}}});

移除目標身上的一個特效效果, 如果指定 <源GID>("<源NPC名>") 則特效會顯示在指定的源實体上

發送目標
   AREA - 發送給可視范圍內的玩家(默認)
   SELF - 發送給自己, 如果指定<目標GID> 則特效只能指定玩家看到
   PARTY_AREA - 發送給可視范圍內的指定隊伍
   GUILD_AREA - 發送給可視范圍內的指定公會
   BG_AREA - 發送給可視范圍內的指定BG隊伍

注意: 本指令只在 20181002 以上客戶端有效. 

---------------------------------------

*getcomputeruid {<角色ID>};

獲取玩家机器碼, 只有客戶端加載了防外挂dll才可以使用

---------------------------------------

*getsameuidinfo {<玩家机器碼>};

獲得某個机器碼在線的玩家數以及玩家的角色編號等信息.

如果執行成功的話, 會賦予以下數組在線玩家的信息:

$@sameuid_aid[]		使用指定机器碼在線的玩家賬號編號數組(AccountID)
$@sameuid_cid[]		使用指定机器碼在線的玩家角色編號數組(CharID)
$@sameuid_name$[]	使用指定机器碼在線的玩家角色名數組

$@sameuid_amount 使用指定机器碼登錄的玩家個數.

---------------------------------------

*countrentitem(<物品ID>{,<賬號ID>})
*countrentitem2(<物品ID>,<鑒定>,<精煉>,<屬性>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<賬號ID>})
*countrentitem3(<物品ID>,<鑒定>,<精煉>,<屬性>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})
*countrentitem3("<item name>",<鑒定>,<精煉>,<屬性>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})

指令用于獲取租賃物品的數量, 可以用于制作的時候, 通過 (countitem - countrentitem) 計算出非租賃物品的數量, 用法請參考 countitem

---------------------------------------

*monster     "<地圖名>",<x>,<y>,"<顯示的名稱>",<魔物ID>,<數量>{,"<死亡触發標簽>",<体型>,<AI>};
*areamonster "<地圖名>",<x1>,<y1>,<x2>,<y2>,"<顯示的名稱>",<魔物ID>,<數量>{,"<死亡触發標簽>",<体型>,<AI>};

指令返返回最后一個召喚魔物的GID, 召喚失敗返回0, 此指令只在原指令上做了返回ID的优化, 便于寫腳本

---------------------------------------

*getbrokencount({<角色ID>});

獲取背包中損坏裝備的數量。

---------------------------------------

*mobattached();

腳本是否与魔物相關聯, 是則返回魔物GID, 否則返回 0;
一般用于 OnTouchNPC 獲取關聯魔物, 与 getattachedrid + getunittype 用法相同。

---------------------------------------

*setgroupid <權限等級>{,<角色ID>};
*setgroupid <權限等級>{,<"角色名">};

賦予玩家新的權限等級, 玩家不在線會失敗并報錯.

---------------------------------------

getunitstatus <GID>,<類型>;
getunitstatus <類型>;

獲得相應GID (玩家、魔物、寵物、生命体、佣兵、元素、NPC) 的戰斗屬性.

類型:
	STATUS_HP			血量
	STATUS_SP			藍量
	STATUS_MAXHP		最大血量
	STATUS_MAXSP		最大藍量
	STATUS_STR			總力量值
	STATUS_AGI			總敏捷值
	STATUS_VIT			總体力值
	STATUS_INT			總智力值
	STATUS_DEX			總靈巧值
	STATUS_LUK			總幸運值
	STATUS_ATK			總物攻
	STATUS_ATK_L		物攻(左值) 或 除玩家外獲得最小物攻
	STATUS_ATK_R 		物攻(右值) 或 除玩家外獲得最大物攻
	STATUS_MATK			總魔攻
	STATUS_MATK_L		魔攻(左值) 或 除玩家外獲得最小魔攻
	STATUS_MATK_R		魔攻(右值) 或 除玩家外獲得最大魔攻
	STATUS_SPEED		移動速度
	STATUS_ADELAY		攻擊后延遲
	STATUS_AMOTION		攻擊后行走延遲
	STATUS_DMOTION		被攻擊后延遲
	STATUS_MODE			MODE
	STATUS_HIT			命中率
	STATUS_FLEE_L		回避率
	STATUS_FLEE_R		完全回避
	STATUS_CRI			暴擊率
	STATUS_DEF_L		物防(左值)
	STATUS_DEF_R		物防(右值)
	STATUS_MDEF_L		魔防(左值)
	STATUS_MDEF_R		魔防(右值)
	STATUS_ATK_ELE		攻擊屬性
	STATUS_ATK_RANGE	攻擊范圍
	STATUS_DEF_ELE		防御屬性
	STATUS_DEF_ELE_LV 	防御屬性等級
	STATUS_SIZE			体型
	STATUS_RACE			种族
	STATUS_CLASS		職業(外觀ID)
	STATUS_ASPD			攻速
	
返回值:
	相應的戰斗屬性

----------------------------------------

*skf_src_status <類型>;

獲取攻擊者的基礎屬性, 用于自定義技能公式, 必須在 skill_formula_db.yml 文件中使用..

類型:
	參考 getunitstatus 指令

----------------------------------------

*skf_target_status <類型>;

獲取目標(被攻擊者)的基礎屬性, 用于自定義技能公式, 必須在 skill_formula_db.yml 文件中使用..

類型:
	參考 getunitstatus 指令

----------------------------------------

*skf_attr_fix <傷害>;

計算本次傷害的屬性修正, 用于自定義技能公式, 必須在 skill_formula_db.yml 中的 Formula 部分使用..

----------------------------------------

*skf_card_fix <傷害>,<攻擊類型>{,<NK>{,<左手右手>}};

計算本次傷害的 BONUS 修正, 用于自定義技能公式, 必須在 skill_formula_db.yml 中的 Formula 部分使用..

攻擊類型:
按攻擊范圍:
	BF_SHORT:  近距离攻擊
	BF_LONG:   遠距离攻擊
	默認:   BF_SHORT+BF_LONG
按攻擊類型:
	BF_WEAPON: 物理攻擊
	BF_MAGIC:  魔法攻擊
	BF_MISC:   混合攻擊
	默認:   BF_WEAPON
按技能類型:
	BF_NORMAL: 普通攻擊
	BF_SKILL:  技能攻擊
	默認:   如果攻擊類型是 BF_WEAPON (only) BF_NORMAL, 否則 BF_SKILL+BF_NORMAL.
	
NK: 為 skill_db.txt 中的 NK項 填寫-1為技能默認
	0x01 - No damage skill
	0x02 - Has splash area
	0x04 - Damage should be split among targets
	0x08 - Skill ignores caster's % damage cards (misc type always ignores)
	0x10 - Skill ignores elemental adjustments
	0x20 - Skill ignores target's defense (misc type always ignores)
	0x40 - Skill ignores target's flee (magic type always ignores)
	0x80 - Skill ignores target's def cards
	0x100 - Skill can critical (藍色框框顯示傷害)

<左手右手>
BF_MISC and BF_MAGIC ignore flag value
	3: Calculates attacker bonuses in both hands.
	2: Calculates attacker bonuses in right-hand only.
	0 or 1: Only calculates target bonuses.

----------------------------------------

*atcommand <"GM指令">{,<標簽>};
*useatcmd <"GM指令">{,<標簽>};

讓玩家使用一個GM指令, atcommand忽略指令權限, 添加標簽參數, 控制是否顯示指令輸出信息 (綠色字)

標簽:
	1 不輸出GM指令信息
	0 或 忽略 輸出GM指令標簽

----------------------------------------

*progressbar_unit("<顏色>",<秒>{,<GID>});

在GID對應的目標頭上顯示一個讀條進度
与 progressbar(progressbar_npc)不同的是, 腳本不會暫停, 而是會繼續運行
如果GID不存在則進度會顯示在与腳本關聯的玩家頭上

----------------------------------------

*getvariableofpc(<變量>,<玩家AID>{,<默認值>});

腳本返回指定玩家的變量, 如果玩家不存在則返回默認值

例子:

//將返回玩家名為 player 的 @var 變量, 如果玩家不存在則返回0
	.@v = getvariableofpc(@var, getcharid(CHAR_ID_ACCOUNT, "player"));

//設置玩家名為 player 的 @var 變量為 1
	set(getvariableofpc(@var, getcharid(CHAR_ID_ACCOUNT, "player")), 1);

----------------------------------------

*getcalendartime(<時>,<分>{,<月份的第几天>{,<每周的第几天>}});

指令返回下次出現指定時間的時間戳

月份的第几天介于 1 至 31 之間, 默認值為 -1 即忽略月份.
每周的第几天的值為:
	0 - SUNDAY
	1 - MONDAY
	2 - TUESDAY
	3 - WEDNESDAY
	4 - THURSDAY
	5 - FRIDAY
	6 - SATURDAY

如果設置每周的第几天与每月的第几天沖突
如果想獲取每周第几天某個時段的時間戳, 則每月的第几天必須為 -1. 否則返回 -1.

例子:
	getcalendartime(19, 00); // 獲得下次 19:00 的時間戳
	getcalendartime(19, 00, 6); // 獲得下次 6號 19:00的時間戳
	getcalendartime(19, 10, -1, 1); // 獲得下次 周一 19:10 的時間戳
	
----------------------------------------

*sprintf(<格式文本>{,參數{,參數{, ...}}});

C語言樣式的sprintf. 將參數帶入格式并輸出最終字符串.

格式字符串可以使用以下結构﹕

  %[參數排序符][flags][width]specifier

格式文本支持以下說明符:

%%: 輸出一個 '%' (特殊情況，不支持參數、標志、寬度)
%d, %i: 有符號十進制整數
%u: 無符號十進制整數
%x: 無符號十六進制整數
%X: 無符號十六進制整數（大寫字母）
%o: 有符號八進制
%s: 字符的字符串
%c: 字符（僅使用字符串的第一個字符）

格式文本不支持以下說明符﹕

%n (出于安全考慮不支持)
%f, %F, %e, %E, %g, %G (腳本引擎不支持浮點類型)
%p (腳本引擎不支持指針)
%a, %A (不支持, 請分別使用 0x%x 和 0x%X 替代)

參數排序符:

可以通過 'x$' 指定格式文本中的說明符分別使用哪個參數 ( x 是一個數字, 代表引用第几個參數),
他可以將參數重新排序 (這在翻譯字符串中可能有用，因為句子順序可能与原始順序不同). 

例子:
	// 當翻譯成其他語言時, 可能因為參數的順序不同, 而需要顛倒參數的情況, 可以通過 'x$' 重新排序參數
	mes(sprintf("Hello, It's %d minutes after %d o'clock.", gettime(DT_MINUTE), gettime(DT_HOUR))); // 例句
	mes(sprintf("你好, 現在是 %2$d點 %1$d分", gettime(DT_MINUTE), gettime(DT_HOUR))); // 譯句

格式文本支持的 flags（標識）有:

- (減號): 在給定的字段寬度內左對齊，默認是右對齊（參見 width 子說明符）
+ (加好): 強制在結果之前顯示加號或減號（+ 或 -），即正數前面會顯示 + 號。默認情況下，只有負數前面會顯示一個 - 號。
(空格): 如果沒有寫入任何符號，則在該值前面插入一個空格。
0 (零): 在指定填充 padding 的數字左邊放置零（0），而不是空格（參見 width 子說明符）

	mes(sprintf("現在的溫度是 %+d 攝氏度", 25)); // 數值前面保留 '+' 號
	.@map_name$ = sprintf("quiz_%02d", .@i); // 位數不組寬度 2, 在前面填充 0, 所以輸出 "quiz_00"

可以在參數中指定字段寬度，以确保至少填充多少個字符。如果使用('*')作為指定寬度，
則寬度將作為sprintf()函數的參數讀取

	sprintf("%04d", 10) // Returns "0010"
	sprintf("%0*d", 5, 10) // Returns "00010"
	sprintf("%5d", 10) // Returns "   10"
	sprintf("%-5d", 10) // Returns "10   "
	sprintf("%10s", "Hello") // Returns "     Hello";
	sprintf("%-10s", "Hello") // Returns "Hello    ";

精度 ('.precision') 和 長度 ('hh', 'h', 'l', 'll', 'L', 'z', 'j', 't') 未實現, 腳本引擎不需要.

例子:
	.@format$ = "The %s contains %d monkeys";
	dispbottom(sprintf(.@format$, "zoo", 5));
	//prints "The zoo contains 5 monkeys"

	dispbottom(sprintf(.@format$, "barrel", 82));
	//prints "The barrel contains 82 monkeys"
	
----------------------------------------

*mesf <格式文本>{,參數{,參數{, ...}}};

在NPC對話框打印一句話, 同 mes,具体使用方法參見 sprintf

例句:

	mesf("你好, 我是 %s, 一名等級為 %d 的 %s", strcharinfo(PC_NAME), BaseLevel, jobname(Class));
	// is equivalent to:
	mes(sprintf("你好, 我是 %s, 一名等級為 %d 的 %s", strcharinfo(PC_NAME), BaseLevel, jobname(Class)));

指令是 mes() 和 sprintf() 的簡化版.

----------------------------------------

*consolemes("<類型>","<格式文本>"{,<參數>{,<參數>{, ...}}})

在控制台打印文本, 第2個參數往后使用的是類似于sprintf的格式

<類型>:
	MSG_DEBUG		調試信息
	MSG_ERROR		錯誤信息
	MSG_WARNING		警告信息
	MSG_INFORMATION	普通信息
	MSG_STATUS 		狀態信息
	MSG_NOTICE 		注意信息
Example:

	consolemes(CONSOLEMES_DEBUG, "%s 點擊了我!", strcharinfo(PC_NAME));
	consolemes(CONSOLEMES_DEBUG, "\033[0;32mHello World"); // 支持顏色代碼

----------------------------------------
	
*setequipedcard <裝備位置編號>,<第几個卡槽>,<物品ID>{,<角色ID>};

在已裝備的道具中設置相應卡槽中的物品, 不會在窗口提示卸下再穿上裝備.
如果 卡片ID 為 0 則拆下相應卡槽的道具
注意: 設置卡槽不會對背包中任何道具增加或刪除

<裝備位置編號> 是指 EQI_* 開頭的位置常量
<第几個卡槽> 從0開始 0~3的數字
<物品ID> 為你想要插入卡槽的物品, 可以是任何物品

----------------------------------------

*abs(<數字>);

返回數字絕對值

----------------------------------------

*addmobskill <GID>,"<技能格式>";

給指定GID的魔物增加一個技能, 不影響其他魔物, <技能格式> 參見 mob_skill_db.txt 文本格式
注意: 一個魔物最多只能有50個技能

例子:
// monster "prontera",155,106,"12345",1029,1;
// addmobskill $@mobid,"1029,Scorpion@NPC_FIREATTACK,attack,14,10,10000,0,0,yes,target,always,0,,,,,,,"; 

----------------------------------------

*delmobskill <GID>,<技能ID>;

給指定GID的魔物刪除技能, 魔物擁有的指定技能都會被刪除

特殊情況:
技能ID為0, 還原魔物為原版的技能列表
技能ID為1, 則刪除該魔物的所有技能

----------------------------------------

*mapcutin "<地圖名稱>","<文件名>",<位置>;

給指定地圖上的所有玩家都顯示同一張照片, 參數參考 cutin

----------------------------------------

*end2;

只結束腳本不影響NPC對話和商店

----------------------------------------

*battle_check(<GID>,<GID>,<關系掩碼>)

判斷兩個GID之間是否是所提供的敵對/友好關系

戰斗關系掩碼:
	BCT_SELF		= 0x010000, ///< 自己, 如果兩個GID為相同時, 返回真
	BCT_ENEMY		= 0x020000, ///< 敵對
	BCT_PARTY		= 0x040000, ///< 隊友
	BCT_GUILDALLY	= 0x080000, ///< 公會盟友關系, 但非同公會
	BCT_NEUTRAL		= 0x100000, ///< 中立
	BCT_SAMEGUILD	= 0x200000, ///< 同公會, 非公會盟友

	BCT_GUILD		= BCT_SAMEGUILD|BCT_GUILDALLY,	///< 公會成員和盟友
	BCT_NOGUILD		= BCT_ALL&~BCT_GUILD,			///< 非公會同盟
	BCT_NOPARTY		= BCT_ALL&~BCT_PARTY,			///< 非隊友
	BCT_NOENEMY		= BCT_ALL&~BCT_ENEMY,			///< 非敵對

返回值:
  返回 0 兩者無任何關系, 不能作為目標(例 玩家和NPC 魔物和魔物之間), 
  返回 1 關系成立
  返回 -1 關系不成立

----------------------------------------

*instance_addmap(<"地圖名稱">{{,<是否复制NPC>},<副本ID>});

在副本中添加任意地圖, 副本中不能同時存在兩個同樣的地圖, 可以刪除副本地圖后重新加入

是否复制NPC: (默認复制)
	為 1 時 复制 
	為 0 時 不复制

返回值:
	成功返回 1 失敗返回 0
	
----------------------------------------

*instance_delmap(<"地圖名稱">,<副本ID>);

刪除副本中已存在的地圖

返回值:
	成功返回 1 失敗返回 0

----------------------------------------

*itemlist <物品數組>{,<角色ID>};

生成一個物品選擇框, 返回選中的物品ID, 失敗返回 0 

----------------------------------------

*skilllist <技能數組>{,<角色ID>};

生成一個物品選擇框, 返回選中的技能ID, 失敗返回 0

----------------------------------------

*getconstantstr <"常量前綴">,<常量值>;

通過數值獲取常量的字符串, 加常量前綴可以增加獲得常量字符串的准确度

例:
	dispbottom getconstantstr("b",2010); // 輸出 bUnbreakableHelm

返回值:
	成功返回常量字符串, 失敗返回空白字符串

----------------------------------------

*next_dropitem_special <是否綁定>,<租賃時長>,<掉落光環顏色>;

下一次掉落在地上的物品, 會按照本次設定的特殊要求掉落
對玩家和魔物掉落同樣有效, 如果只想對 makeitem、makeitem2、makeitem3 有效, 請在此指令下緊接著使用makeitem

是否綁定:
	1 為綁定 0為不綁定
	
租賃時長:
	單位 秒
	
掉落光環顏色:
	// -1 - 默認光環
	//  0 - 無光效
	//  1 - 客戶端定義的光效
	//  2 - 白色柱形掉落光效
	//  3 - 藍色柱形掉落光效
	//  4 - 黃色柱形掉落光效
	//  5 - 紫色柱形掉落光效
	//  6 - 橙色柱形掉落光效

----------------------------------------

*unitdefratefixed <GID>,<倍率>{,<倍率分母>{,<最小傷害>{,<最大傷害>}}};

使對應的對象獲得的傷害變為倍率后的傷害, 最小傷害不低于<最小傷害>, 最大傷害不高于<最大傷害> 

例:
	monster "prontera",155,106,"12345",1002,1;
	unitdefratefixed $@mobid[0],1000,10000;

<倍率分母> 默認 100

----------------------------------------

*settitleicon <GID>,<圖標組ID>,<標題>;

使某個GID顯示圖標和標題, 對任意單位都有效
用于玩家時不能正常顯示圖標, 指令可以屏蔽掉公會隊伍等信息
用于其他單位時, 可在名字上面顯示額外的文字, 并在左側顯示標題

---------------------------------------

*setinventoryinfo <背包位置序號>,<要設置的類型>,<要設置的數字>{,<角色ID>};
*setequipedinfo <裝備位置編號>,<要設置的類型>,<要設置的數字>{,<角色ID>};

改變背包中的物品/裝備相應的數据, 將指定指定背包/裝備的 <要設置的類型> 改變為 <要設置的數字>
注意!! 如果設置多項內容, 必須連續使用指令, 否則可能會造成設置失敗的問題
注意!! 設置完成后不會立即改變背包中的內容, 必須緊跟著使用 refreshinventory 刷新一下道具裝備才會改變

要設置的類型:
	0 	- 物品編號
	1 	- 堆疊數量
	2 	- 裝備的穿戴位置(如果為 0 則表示還沒穿戴在身上, 位置請參考 EQP_* 開頭的常量)
	3 	- 精煉值
	4 	- 是否已經鑒定(1為已鑒定, 0為未鑒定)
	5 	- 屬性(說是屬性, 其實最常用是用來判斷物品是否損坏, 若損坏則返回1, 沒坏則返回 0)
	6 	- 第一個卡槽的卡片編號
	7 	- 第二個卡槽的卡片編號
	8 	- 第三個卡槽的卡片編號
	9 	- 第四個卡槽的卡片編號
	10	- 過期時間(Unix時間戳, 0 表示永不過期)
	11	- 綁定類型
	12	- 裝備的唯一編號(unique_id)
	13	- 裝備的換裝穿戴位置(equipSwitch)
	16  - 是否被玩家收藏.
	
設置物品的 option 格式如下:
特例格式: setinventoryinfo <背包位置序號>,<Random Option序號>,<id>,<value>,<param>{,<角色ID>};
特例格式: setequipedinfo <裝備位置編號>,<Random Option序號>,<id>,<value>,<param>{,<角色ID>};

---------------------------------------

*refreshinventory {<背包位置序號>{,<角色ID>}};
*refreshequip {<裝備位置編號>{,<角色ID>}};

刷新背包中的內容, 如果不提供參數, 則刷新所有的內容.

如果刷新 setinventoryinfo 設置的物品時, 必須提供 <背包位置序號>, 否則刷新無效
如果刷新 setequipedinfo 設置的裝備時, 必須提供 <裝備位置編號>, 否則刷新無效

---------------------------------------

*getskillinfo <類型>,<技能ID>{,<其他參數>};

獲取技能信息

類型:
	1 	- 返回技能施放類型 0 為地面技能, 1 為傷害技能, 2 為無傷害技能
	2	- 返回技能名稱 skill_db 中的 name
	3	- 返回技能說明 skill_db 中的 desc
	4	- 返回技能樹种的最大等級 <其他參數> 傳入職業代碼
	5	- 返回技能攻擊類型 返回 BF_WEAPON BF_MAGIC BF_MISC skill_db 中的 attack type
	6	- 返回打擊類型 skill_db 中的 hit
	7	- 返回技能類型1 skill_db 中的 inf
	8	- 返回技能屬性 skill_db 中的 element <其他參數> 傳入技能等級
	9	- 返回技能傷害類型 skill_db 中的 nk
	10	- 返回技能最大等級 skill_db 中的 max
	11	- 返回技能攻擊距离 skill_db 中的 range <其他參數> 傳入技能等級
	12	- 返回技能濺射范圍 skill_db 中的 splash <其他參數> 傳入技能等級
	13	- 返回技能打擊次數 skill_db 中的 list_num <其他參數> 傳入技能等級
	14	- 返回技能吟唱時間 skill_cast_db 中的 CastingTime <其他參數> 傳入技能等級
	15	- 返回技能公共延遲 skill_cast_db 中的 AfterCastActDelay <其他參數> 傳入技能等級
	16	- 返回技能攻擊僵直 skill_cast_db 中的 AfterCastWalkDelay <其他參數> 傳入技能等級
	17	- 返回技能時刻參數 skill_cast_db 中的 Duration1 <其他參數> 傳入技能等級
	18	- 返回技能時刻參數 skill_cast_db 中的 Duration2 <其他參數> 傳入技能等級
	19	- 返回技能吟唱計算 skill_castnodex_db 中的 Cast
	20	- 返回技能延遲計算 skill_castnodex_db 中的 Delay
	21	- 返回技能施法期間防御降低倍率 skill_db 中的 cast_def_rate
	22	- 返回技能使用限制 skill_nocast_db 中的 Flag
	23	- 返回地面技能單位ID skill_unit_db 中的 Unit id  <其他參數> 傳入 Flag
	24	- 返回技能類型2 skill_db 中的 inf2
	25	- 返回技能是否可被打斷 skill_db 中的 castcancel
	26	- 返回技能最大數量 skill_db 中的 maxcount <其他參數> 傳入技能等級
	27	- 返回技能擊退距离 skill_db 中的 Blowcount <其他參數> 傳入技能等級
	28	- 返回地面技能標記 skill_unit_db 中的 Flag
	29	- 返回技能冷卻 skill_cast_db 中的 Cool Down <其他參數> 傳入技能等級
	30	- 返回地面技能目標 skill_unit_db 中的 Target
	31	- 返回技能類型3 skill_db 中的 inf3
	32	- 返回技能消耗的HP skill_require_db 中的 HPCost <其他參數> 傳入技能等級
	33	- 返回技能有多少HP才可能使用 skill_require_db 中的 MaxHPTrigger <其他參數> 傳入技能等級
	34	- 返回技能消耗的SP skill_require_db 中的 SPCost <其他參數> 傳入技能等級
	35	- 返回技能消耗的百分比HP skill_require_db 中的 HPRateCost <其他參數> 傳入技能等級
	36	- 返回技能消耗的百分比SP skill_require_db 中的 SPRateCost <其他參數> 傳入技能等級
	37	- 返回技能消耗的Zeny skill_require_db 中的 ZenyCost <其他參數> 傳入技能等級
	38	- 返回技能所需的武器類型 skill_require_db 中的 RequiredWeapons
	39	- 返回技能所需的彈藥類型 skill_require_db 中的 RequiredAmmoTypes
	40	- 返回技能所需的彈藥數量 skill_require_db 中的 RequiredAmmoAmount <其他參數> 傳入技能等級
	41	- 返回技能所需的特殊狀態 skill_require_db 中的 RequiredState
	42	- 預留
	43	- 返回技能所需的一般狀態個數 skill_require_db 中的 RequiredStatuses 個數
	44	- 返回技能所需气球個數 skill_require_db 中的 SpiritSphereCost
	45	- 返回技能所需物品ID skill_require_db 中的 RequiredItemID <其他參數> 傳入第几項消耗品
	46	- 返回技能所需物品數量 skill_require_db 中的 RequiredItemAmount <其他參數> 傳入第几項消耗品

---------------------------------------

*getequipinfo {<獲取類型>};

 在裝備的 item_script 中使用可以獲得裝備在背包中的IDX 和 裝備ID

<獲取類型>:

	- INV_ID   裝備ID
	- INV_IDX  裝備在背包中的IDX(默認)

---------------------------------------

*getcardinfo {<獲取類型>};

 在卡片的 item_script 中使用可以獲得卡片在裝備卡槽中的IDX 和 卡片ID

<獲取類型>:
	- INV_ID   卡片ID
	- INV_IDX  卡片在裝備卡槽中的IDX(默認)

---------------------------------------

*getrandomoptinfo(<獲取類型>);

官方指令, 請查看 doc\script_commands.txt

---------------------------------------

*mobaggroswitch <GID>,<開關狀態>;

打開或關閉指定魔物的仇恨系統, 當戰斗配置 mob_aggro_all_mob 關閉時有效

<開關狀態>:
	- 1 開啟魔物的仇恨系統
	- 0 關閉魔物的仇恨系統

---------------------------------------

*instance_id(<模式>{,<角色ID>});

獲取副本ID, 可通過角色ID獲取角色的副本ID, 當模式為 IM_NONE 時, 不判定副本模式

---------------------------------------

*broadcast_item(<玩家AID>,<物品ID1>,<物品ID2>,<公告類型>);

彈出一條物品廣播

公告類型﹕
	- 0 和 1 公告 msgstring.txt 中的 1629 行
	- 2 公告  msgstring.txt 中的 1870 行, 此時 <物品ID2> 無效

----------------------------------------

*getmapinfo("<地圖名稱>",<類型>{,<角色ID>});

獲取地圖相關的信息, 當地圖名稱為 "this" 時表示獲取關聯(指定)玩家所在地圖的地圖信息

類型:
	- 1: 地圖ID
	- 2: 地圖名稱
	- 3: 地圖的副本ID
	- 4: 地圖寬度
	- 5: 地圖長度
	- 6: 地圖魔物刷新數据 (返回條數, 魔物ID和數量存在數組 $@spawn_mobid, $@spawn_amount 中)

----------------------------------------

*getmobspawninfo(<魔物ID>);

獲取魔物在哪些地圖生成
	
如果執行成功的話, 會賦予以下數組魔物生成的信息:

	$@spawn_mapname$[]		地圖名稱
	$@spawn_amount[]		生成數量
	
指令返回獲取到的個數, 即變量的成員數量

----------------------------------------

*getbossinfo({"<地圖名>"{,<魔物ID>}});

獲取使用 boss_monster 標簽召喚出來的魔物的信息
當地圖名為 "all" 時為所有地圖, "this" 時為關聯玩家所在地圖
	
如果執行成功的話, 會賦予以下數組魔物生成的信息:

	$@boss_gid[]		魔物的gid(可通過 getmobdata 獲取其他信息)
	$@boss_spawn[]		魔物重生倒數(毫秒, 0 表示已重生)
	
指令返回獲取到的個數, 即變量的成員數量

----------------------------------------

*checktrade({<角色ID>});

檢查玩家是否正在交易, 并返回交易對方的 AID

----------------------------------------

*checkcashshop({<角色ID>});

檢查玩家是否正在使用 cashshop 現金商城

----------------------------------------

*checkmailwriting({<角色ID>});

檢查玩家是否正在寫郵件

----------------------------------------

*checkrefineui({<角色ID>});

檢查玩家是否正在使用精煉UI

----------------------------------------

*unitaura <GID>,<特效ID>{,<間隔時間>};

為指定實体增加一個光環特效, 如果是短特效則每過間隔時間播放一次特效

----------------------------------------

*unitdelaura <GID>,<特效ID>;

為指定實体移除一個光環特效
在客戶端版本大于 20181002 會直接移除特效

----------------------------------------

*disablenpc "<NPC名稱>"{,<角色ID>};
*enablenpc "<NPC名稱>"{,<角色ID>};
*hideonnpc "<NPC名稱>"{,<角色ID>};
*hideoffnpc "<NPC名稱>"{,<角色ID>};
*cloakonnpc "<NPC名稱>"{,<角色ID>};
*cloakoffnpc "<NPC名稱>"{,<角色ID>};

從之前指令基礎上增加了對單個玩家的支持, 單個玩家支持只對當前登陸有效
如果想讓此長期有效則需使用 OnPCLoginEvent 對NPC進行隱藏

----------------------------------------

*disableontouch "<NPC名稱>"{,<角色ID>};
*enableontouch "<NPC名稱>"{,<角色ID>};

開啟或關閉NPC的 OnTouch 触發, 可針對角色使用
本指令 覆蓋 disablenpc enablenpc hideonnpc hideoffnpc cloakonnpc cloakoffnpc 的默認触發配置

----------------------------------------

*setwall "<地圖名>",<x>,<y>,<長度>,<角度>,<是否可以穿透攻擊>,"<牆名字>"{,<召喚魔物ID>,"<召喚魔物名字>"};
*setwallline "<地圖名>",<x0>,<y0>,<x1>,<y1>,<是否可以穿透攻擊>,"<牆名字>"{,<召喚魔物ID>,"<召喚魔物名字>"};
*setwallcircle "<地圖名>",<x>,<y>,<半徑>,<是否可以穿透攻擊>,"<牆名字>"{,<召喚魔物ID>,"<召喚魔物名字>"};

在地圖上生成一堵牆, 可在牆的坐標點召喚不能被攻擊的魔物作為標記

指令 setwall 為原版指令
指令 setwallline 由坐標 (x0,y0) 到 (x1,y1) 畫直線, 畫線, 本指令采用 Bresenham 算法
指令 setwallcircle 以坐標 (x,y) 為圓心, 以<半徑>畫圓, 本指令采用 Bresenham 算法

當生成副本時, 副本源地圖上如果有牆時, 牆可以被复制到副本中, 副本中的牆可以通過 delwall 刪除
本指令經過优化, 可以在副本中隨意使用, 在執行 @reloadscript 牆會被釋放通過 OnInit 重新畫牆, 副本中的牆也會被重置

----------------------------------------

*delwall "<牆名字>"{,<副本ID>};

通過牆名字刪除牆, 當刪除副本中的牆時, 必須加入副本ID

----------------------------------------

*checkwall "<牆名字>"{,<副本ID>};

查詢牆是否存在, 當查詢副本中的牆時, 必須加入副本ID

----------------------------------------

*delwallmap "<地圖名>";

刪除地圖上的所有牆

----------------------------------------

*getlinexy <x0>,<y0>,<x1>,<y1>,<返回x坐標數組>,<返回y坐標數組>;

獲得坐標 (x0,y0) 到 (x1,y1) 直線上的坐標, 并存入<返回x坐標數組>,<返回y坐標數組>中
----------------------------------------

*getcirclexy <x>,<y>,<半徑>,<返回x坐標數組>,<返回y坐標數組>;

獲得坐標 (x,y) 為圓心, 以<半徑>圓的坐標, 并存入<返回x坐標數組>,<返回y坐標數組>中

----------------------------------------

*array_keys <數組>,<存入數組>;

獲取數組中所有值非0(非空字符串)的鍵, 并將鍵存入指定的數組中, 主要用于以玩家的aid或cid作為鍵值的數組(.@damage[getcharid(0)] += 100)

什么是鍵? 
	數組變量[鍵] = 值; 其中鍵即中括號中改的內容

例: 
	.@test[5] = 1;
	.@test[3] = 2;
	.@test[1024] = 9918;
	.@test[789523] = 12345678;
	array_keys .@test,.@idx;
	for (.@i = 0; .@i < getarraysize(.@idx); .@i++)
		dispbottom "key: "+.@idx[.@i]+" value: "+.@test[.@idx[.@i]];
	// 輸出:
	// 	key: 5 value: 1;
	// 	key: 3 value: 2;
	// 	key: 1024 value: 9918;
	// 	key: 789523 value: 12345678;
	
返回值: 
	獲取到鍵的數量

----------------------------------------

*getarrayindex <數組>;

獲取數組變量中的 key 值, 一般用在函數調用中獲取傳參 getarg() 的源變量中括號中的數字

什么是鍵? 
	數組變量[鍵] = 值; 其中鍵即中括號中改的內容

例子:
	getarrayindex(.@foo[42]); // 42
	
	getindex(.@foo[36]);
	function	script	getindex	{
		getarrayindex(getarg(0)); // 36
	}

----------------------------------------

*countnameditem(<物品ID>, "<角色名>")
*countnameditem(<物品ID>, <角色ID>)
*countnameditem("<物品名>", "<角色名>")
*countnameditem("<物品名>", <角色ID>)

獲取身上有多少個署名物品, 具体參考 getnameditem. 

---------------------------------------

*getguildinfo(<信息類型>{,<公會ID>})
*getguildinfo(<信息類型>{,"<公會名稱>"})

獲取指定類型的公會相關數据

<信息類型>:
	GUILDINFO_NAME          - 公會名稱
	GUILDINFO_ID            - 公會ID
	GUILDINFO_LEVEL         - 公會等級
	GUILDINFO_EXP           - 公會經驗
	GUILDINFO_NEXT_EXP      - 距离下一級升級的經驗
	GUILDINFO_SKILL_POINTS  - 公會剩余技能點數
	GUILDINFO_ONLINE        - 公會在線人數
	GUILDINFO_AV_LEVEL      - 公會成員平均等級
	GUILDINFO_MAX_MEMBERS   - 公會最大成員數
	GUILDINFO_MASTER_NAME   - 公會會長名稱
	GUILDINFO_MASTER_CID    - 公會會長角色ID

例子:
	getguildinfo(GUILDINFO_MASTER_NAME, getcharid(2, "Haru"))

---------------------------------------

*gettimer(<類型>{,<角色ID>{,"<事件>"}})

返回由 addtimer() 創建的玩家時鐘的相關信息. 如果未指定事件則為所有事件

<類型>:
	TIMER_COUNT       - 玩家有多少個 "<事件>" 相關的時鐘.
    TIMER_TICK_NEXT   - 玩家触發下一次 "<事件>" 還有多少毫秒.
    TIMER_TICK_LAST	  - 玩家触發最后一次 "<事件>" 還有多少毫秒.

---------------------------------------

*setnpcdistance(<距离>)

指令玩家距必須靠近NPC多少格之內才可以點擊, 一般使用在 OnInit 事件下設置.

例子:
	OnInit:
		setnpcdistance(1);

---------------------------------------

*getdatatype(<參數>)

返回給定<參數>的原始類型. 返回的類型是掩碼類型.

返回類型:
	DATATYPE_NIL
	DATATYPE_STR
	DATATYPE_INT
	DATATYPE_CONST
	DATATYPE_PARAM
	DATATYPE_VAR
	DATATYPE_LABEL

例子:
	getdatatype() // DATATYPE_NIL
	getdatatype("foo") // DATATYPE_STR
	getdatatype(@foo$) // (DATATYPE_VAR | DATATYPE_STR)

---------------------------------------

*tostring(<參數>)

將給定的參數轉換為字符串類型.

例子:
	tostring(DATATYPE_VAR) // "DATATYPE_VAR"
	tostring(.@foo) // ".@foo"
	
---------------------------------------

*chr(<數字>)

返回整數對應的 ASCII 字符.

例子:
    chr(99); //returns "c"

---------------------------------------

*ord(<字符>)

返回字符對應的 ASCII 數值.

例子:
    ord("c"); //returns 99

---------------------------------------

*log10(<數值>)

返回傳入數值 log 10 的結果.

例子:
	.@i = log10(100); // 2

---------------------------------------

*swap(<變量>,<變量>)

交換兩個變量的值, 兩邊必須同時為整數或字符串類型.

例子:
	.@var1 = 111;
	.@var2 = 222;
	swap(.@var1, .@var2);
	mes("var1 = "+ .@var1); // return 222
	mes("var2 = "+ .@var2); // return 111

---------------------------------------

*unitiswalking({<GID>})

指令檢查一個單位是否在行走. 省略 GID 則為關聯玩家

返回值:
	1 為正在行走, 0 為沒有行走

---------------------------------------

*mercenary_delete({<角色ID>,<忠誠更新>})

刪除指定玩家的佣兵.

忠誠更新:
    0 - 佣兵忠誠增加 1，類似于合同結束 (默認).
    1 - 佣兵忠誠降低 1，類似于佣兵死亡.
	2 - 佣兵忠誠不變.

---------------------------------------

*msgtable(<信息ID>{,<顏色代碼>})

顯示一條 msgtable.txt 中的字符串

顏色代碼:
	COLOR_DEFAULT       - 默認
	COLOR_RED           - 紅色
	COLOR_WHITE         - 白色
	COLOR_YELLOW        - 黃色
	COLOR_CYAN          - 青色
	COLOR_LIGHT_GREEN   - 淺綠

---------------------------------------

*monster     "<地圖名>",<x>,<y>,"<顯示名稱>",<魔物ID>,<數量>{,"<触發事件>",<体型大小>,<魔物ai>};
*areamonster "<地圖名>",<x1>,<y1>,<x2>,<y2>,"<顯示名稱>",<魔物ID>,<數量>{,"<地圖名>",<体型大小>,<魔物ai>};
*bg_monster <戰場分組>,"<地圖名>",<x>,<y>,"<顯示名稱>",<魔物ID>，"<触發事件>";
*tribe_monster <陣營編號>,"<地圖名字>",<x>,<y>,"<魔物名字>",<魔物ID>,"<事件標簽>";
*guardian "<地圖名>",<x>,<y>,"<顯示名稱>",魔物ID>{,"<触發事件>"{,<guardian index>}};

可通過 playerattached 判斷是否是玩家殺死的魔物。

事件返回變量:
	
	注意: 因事件在遇到玩家正在運行時會排隊, 所以与玩家關聯時使用全局變量返回值會被其他擊殺覆蓋, 
	如果你開啟了 disable_mobdead_queue 則無需顧慮此問題可以直接使用全局變量
	
	如果是玩家殺死, 則返回:
		killedgid			被殺死魔物的GID
		killedrid			被殺死魔物的魔物編號(MobID)
		killerrid			殺死魔物的實体GID
	
	如果是魔物殺死, 則返回: 
		$killedgid			被殺死魔物的GID
		$killedrid			被殺死魔物的魔物編號(MobID)
		$killerrid			殺死魔物的實体GID

---------------------------------------

*dual_weapon <開關>{,<角色ID>};

允許玩家雙持武器, 如果打開兩次雙持后, 必須關閉兩次才會取消玩家雙持.

<開關>: 
	1為開 0為關

----------------------------------------

*inventory_mark <類型>{,<參數>};

對一個物品增加標記, 此指令用于物品腳本、卡片腳本或隨机屬性腳本中, 指令只用于標記物品, 對邏輯判斷無效。

類型: 
	EquipLoc           更改裝備穿戴位置, <參數> 為穿戴位置
	EquipBound         更改裝備綁定類型, <參數> 為綁定類型 (BOUND_NONE BOUND_ACCOUNT BOUND_GUILD BOUND_PARTY BOUND_CHAR)
	EquipIgnoreFunc    無效裝備指定屬性, <參數> 無效
	EquipIgnoreClass   移除裝備職業限制, <參數> 無效

----------------------------------------

*itempreview <背包位置序號>;

刷新正在打開瀏覽的物品說明
本指令只能在客戶端版本大于 20170726 之后的版本才能使用 

----------------------------------------

*getskillsc(<技能ID>);

獲取技能使用后給玩家附加的狀態ID, 可用于BOT相關的狀態條件

----------------------------------------

*pctalk <目標>,"<信息內容>"{,<角色ID>};

發送一條聊天信息給指定目標或群組

<目標>
	0       - 公開發言
	隊伍ID  - 隊伍發言(隊伍ID必須是發言玩家自己的隊伍)
	公會ID  - 公會發言(公會ID必須是發言玩家自己的公會)
	玩家AID - 私聊玩家(玩家必須在線)

----------------------------------------

*pcjoinchat <GID>{,<角色ID>};

加入一個与指定GID的玩家或NPC相關的聊天室

----------------------------------------

*unitblown <GID>,<坐標X>,<坐標Y>{,<是否檢查>};

移動個体到指定的坐標, 移動玩家時沒有黑屏的傳送動畫, 移動過程中檢查路徑, 遇到牆會移動失敗

是否檢查:
	是否檢查玩家移動到目標點的路徑(默認: 2)
	1 - A*檢查是否能移動到終點
	2 - 簡單檢查
	3 - 長距檢查
	
----------------------------------------

*unitmove <GID>,<坐標X>,<坐標Y>;

移動個体到指定的坐標, 移動玩家時沒有黑屏的傳送動畫, 不做任何檢查, 甚至可以移動到無法移動的坐標
當魔物移動到無法移動的格子時, 請先禁止其移動, 否則移動足夠多次數后服務端會報錯

----------------------------------------

refineui_result <背包位置序號>,<動畫類型>,<精煉后等級>;

指令用于自定義精煉UI, 播放精煉動畫, 并修改物品精煉值

動畫類型:
	0 - 精煉成功
	1 - 精煉失敗, 裝備消失
	2 - 精煉失敗, 精煉降級
	3 - 精煉失敗, 精煉被鐵匠的祝福保級
	
注意: 
	1 - 當 OnPCRefineUIFilter 事件被打斷后才可以使用該指令
	2 - 精煉成功或精煉失敗, 都會將物品精煉等級直接設置為 <精煉后等級>
	3 - 此精煉不消耗任何道具, 請使用 delitem 刪除精煉材料

----------------------------------------

*getitemcombo(<物品ID>,<索引>,<返回數組>{,<角色ID>});

返回物品所綁定的套裝屬性

注意:
	該指令不會重置返回數組, 請在傳入返回數組時重置該數組

返回值:
	數組中所保存的物品數量
	
例子:
	// 運行与物品ID為24090綁定的所有套裝效果
	while(getitemcombo(24090, .@idx++, .@combo)){
		.@combo_str$ = "";
		for (.@i = 0; .@i < getarraysize(.@combo); .@i++)
			.@combo_str$ += ""+.@combo[.@i]+":";
		dispbottom .@combo_str$;
		runcomboscript .@combo;
		deletearray .@combo;
	}

----------------------------------------

*runcomboscript <套裝數組>{,<角色ID>};

運行套裝數組所保存的套裝效果

返回值:
	運行成功返回 1 失敗返回 0

例子:
	setarray .@combo[0],24090,24091,24092;
	runcomboscript .@combo;

----------------------------------------

*startsellitem <物品ID>,<數量>{,<价格>};

為 NPC 綁定的兌換商店增加一個可兌換道具, 并將兌換商店置于編輯狀態

數量:
	當數量為 -1 時為不限兌換數量商店
	
----------------------------------------

*sellitemcurrency <物品ID>,<數量>{,<精煉等級>};

為兌換物品添加一項所需道具, 只能在兌換商店處于編輯狀態時使用
	
----------------------------------------

*endsellitem;

完成兌換道具添加, 結束道具添加的編輯狀態

----------------------------------------

*bartershop {<NPC ID>{,<角色ID>}};

為指定角色開啟一個兌換商店UI

例子:
	// 使用 紅色藥水x2 赤色藥水x4 黃色藥水x8 和 100000Z 兌換一張波利卡片 
	prontera,156,116,0	script	test	56,{
		bartershop;
		end;
	Oninit:
		startsellitem 4001,-1,100000;
		sellitemcurrency 501,2;
		sellitemcurrency 502,4;
		sellitemcurrency 503,8;
		endsellitem;
	}


擴展:	簡易NPC兌換商店可以直接通過商店模式打開一個兌換商店
		簡易兌換商店只能通過一樣物品兌換另一樣物品

簡易NPC兌換商店例子: 50個紅色藥水兌換一張波利卡片.....
	prontera,156,118,0	bartershop	簡易兌換商店	65,4001:501:50,4002:502:50,4003:503:50

----------------------------------------

*query_sql_asyn("<SQL腳本>"{,<變量>{,<變量>{,...}}});

用法同 query_sql 運行sql指令時不會卡服務器, 如果多個查詢并發執行, 則會排隊依次查詢

----------------------------------------

*whodrops(<物品ID>,<魔物數組>,<概率數組>);

指令用于返回掉落指定物品的魔物和概率, 默認只能返回5個, 想返回更多請在网頁定制中修改'最大物品掉落排序數量'
魔物數組与概率數組用于保存返回的數据

例:
	.@count = whodrops(507,.@mobid,.@chance);
	for(.@i = 0; .@i < .@count; .@i++)
		dispbottom ""+.@mobid[.@i]+": "+.@chance[.@i];

返回值:
	返回共有多少組數据

----------------------------------------

*rfifo_int <讀取位置>,<字節數>;

當 OnPCSocketRecvFilter 事件接收到封包時, 可以用本指令獲取‘接收封包’中對應位置的數字數据.

<字節數>
	1 - 讀取字節型數据
	2 - 讀取短整型數据
	4 - 讀取整數型數据
	8 - 讀取長整型數据
	
指令返回獲取到的數字數据

----------------------------------------

*rfifo_str <讀取位置>;

當 OnPCSocketRecvFilter 事件接收到封包時, 可以用本指令獲取‘接收封包’中的文本數据.

指令返回獲取到的文本數据

----------------------------------------

*wfifo_int <寫入位置>,<寫入數字>,<字節數>;

當 OnPCSocketRecvFilter 事件接收到封包時, 可以用本指令改寫‘發送封包’的數字數据
使用該指令后 ‘發送封包’ 將在事件結束后發送給客戶端, 可通過 fifo_debug 取消發送.

<字節數>
	1 - 讀取字節型數据
	2 - 讀取短整型數据
	4 - 讀取整數型數据
	8 - 讀取長整型數据

----------------------------------------

*wfifo_str <寫入位置>,<寫入文本>{,<寫入長度>};

當 OnPCSocketRecvFilter 事件接收到封包時, 可以用本指令改寫‘發送封包’的文本數据
使用該指令后 ‘發送封包’ 將在事件結束后發送給客戶端, 可通過 fifo_debug 取消發送.
如果 <寫入長度> 大于 <寫入文本> 長度, 則填充空字符.

----------------------------------------

*fifo_debug <掩碼>;

將 ‘發送封包’ 或 ‘接收封包’ 打印到控制台, 或是禁止事件結束后發送 ‘發送封包’ 給客戶端.

<掩碼>
	&1 - 打印接收封包
	&2 - 打印發送封包
	&4 - 取消將 wfifo_int wfifo_str 兩個指令整理的封包發送給客戶端

----------------------------------------
--         以下功能為付費功能         --
-- 收費功能可在官网直接下載測試端測試 --
----------------------------------------

*unitskilltowide <GID>,<技能ID>,<技能等級>,<擴散方向>,<步進長度>,<步進范圍>,<步進延時>;
*unitskilltowide <GID>,"<技能名稱>",<技能等級>,<擴散方向>,<步進長度>,<步進范圍>,<步進延時>;
*unitskilltowide2 <GID>,<技能ID>,<技能等級>,<擴散方向>,<步進長度>,<步進范圍>,<步進延時>;
*unitskilltowide2 <GID>,"<技能名稱>",<技能等級>,<擴散方向>,<步進長度>,<步進范圍>,<步進延時>;

使魔物釋放大規模的魔法攻擊, 這個指令只能釋放地面技能, 下面有個例子可以直觀感受一下

擴散方式(掩碼選項)
	&1 東-西方向
	&2 南-北方向
	&4 西南-東北方向
	&8 東南-西北方向
	
實現方式
	unitskilltowide 是通過召喚魔物釋放技能后瞬間刪除實現的
	unitskilltowide2 是通過無視技能釋放距离詠唱等, 連續釋放實現的
	
例:
	unitskilltowide getcharid(3),21,5,15,2,15,1000;
	sleep2 2000;
	unitskilltowide getcharid(3),21,5,15,2,15,0;
	
---------------------------------------

*unitskilltoAOE <GID>,<技能ID>,<技能等級>,<范圍>{,<最大數量>};

指令對周圍的敵人使用相同的技能, 這個指令只能釋放目標鎖定技能

---------------------------------------

*roulette_bonus <物品ID>{,<角色ID>};

設置幸運大轉盤的 bonus 物品。該指令只有打開轉盤的時候有效。
bonus 物品必須為當前搖獎中的物品時才會顯示。
可以配合 OnPCStartRouletteFilter 事件，重定義轉盤規則。

---------------------------------------

*roulette_iteminfo <標簽>,<行>,<列>{,<角色ID>};

獲得幸運大轉盤中物品信息。行數從下往上數。
可以配合 OnPCStartRouletteFilter 事件, 重定義轉盤規則。

<標簽>: 
	1 : 物品ID
	2 : 獲得物品的數量
	3 : flag 對應數据庫轉盤數据中的flag

---------------------------------------

*roulette_open {<行>{,<列>{,<bonus物品>{,<角色ID>}}}};

打開幸運大轉盤, 并且定位到相應位置，如果列為-1時，下次搖獎行會定位到 (行+1)，或設置bonus物品。行數從下往上數
bonus 物品必須為當前搖獎中的物品時才會顯示。
可以配合 OnPCStartRouletteFilter 事件，重定義轉盤規則。

---------------------------------------

*roulette_generate <結果>,<行>,<列>,<bonus物品>{,<角色ID>};

轉盤開始轉動, 停在指定的位置, 并顯示當前搖獎的bonus物品。行數從下往上數
bonus 物品必須為當前搖獎中的物品時才會顯示。
可以配合 OnPCStartRouletteFilter 事件，重定義轉盤規則。

<結果>:
	0 : 成功 下次搖獎行會定位到(行+1)
	1 : 提示失敗, 不會搖獎
	2 : 提示沒有足夠的硬幣, 不會搖獎
	3 : 失敗 下次搖獎會定位到第一行
